14:35:56 - [32minfo[39m: Using current directory as template folder
14:35:56 - [32minfo[39m: Loading a default sample.txt file.
14:35:56 - [34mdebug[39m: fromDirectory
14:35:56 - [34mdebug[39m: fromDirectory
14:35:56 - [34mdebug[39m: fromDirectory
14:35:56 - [34mdebug[39m: fromDirectory
14:35:56 - [34mdebug[39m: fromDirectory
14:35:56 - [34mdebug[39m: fromDirectory
14:35:56 - [34mdebug[39m: fromDirectory
14:35:56 - [34mdebug[39m: constructor
14:35:56 - [34mdebug[39m: constructor
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processDirectory
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:56 - [34mdebug[39m: fromDirectory
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:56 - [34mdebug[39m: isFileInNodeModuleDir
14:35:56 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: fromDirectory
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processDirectory
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: fromDirectory
14:35:58 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:35:58 - [34mdebug[39m: fromDirectory
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: isFileInNodeModuleDir
14:35:58 - [34mdebug[39m: processFile
14:35:58 - [34mdebug[39m: fromDirectory
14:35:58 - [34mdebug[39m: buildGrammar
14:35:58 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. Sözleşmenin Konusu\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n2. Ödeme Emrinin Alınma Zamanı\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n3. Ödemenin Gerçekleştirilmesi\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n4. Ödeme Hizmetine İlişkin Ücret\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n5. Ödeme İşlemlerine İlişkin Bilgilendirme\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n6. An initial payment of ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. Sözleşmenin Konusu\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n2. Ödeme Emrinin Alınma Zamanı\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n3. Ödemenin Gerçekleştirilmesi\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n4. Ödeme Hizmetine İlişkin Ücret\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n5. Ödeme İşlemlerine İlişkin Bilgilendirme\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n6. An initial payment of [{","offset":0,"lineBreaks":32,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2394,"lineBreaks":0,"line":33,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2409,"lineBreaks":0,"line":33,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2429,"lineBreaks":0,"line":33,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2436,"lineBreaks":0,"line":33,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2442,"lineBreaks":0,"line":33,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2450,"lineBreaks":0,"line":33,"col":84}]}
14:35:58 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. Sözleşmenin Konusu\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n2. Ödeme Emrinin Alınma Zamanı\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n3. Ödemenin Gerçekleştirilmesi\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n4. Ödeme Hizmetine İlişkin Ücret\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n5. Ödeme İşlemlerine İlişkin Bilgilendirme\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n6. An initial payment of ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. Sözleşmenin Konusu\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n2. Ödeme Emrinin Alınma Zamanı\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n3. Ödemenin Gerçekleştirilmesi\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n4. Ödeme Hizmetine İlişkin Ücret\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n5. Ödeme İşlemlerine İlişkin Bilgilendirme\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n6. An initial payment of [{","offset":0,"lineBreaks":32,"line":1,"col":1}
14:35:58 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2394,"lineBreaks":0,"line":33,"col":28}}
14:35:58 - [34mdebug[39m: element rule2 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2409,"lineBreaks":0,"line":33,"col":43}
14:35:58 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2429,"lineBreaks":0,"line":33,"col":63}}
14:35:58 - [34mdebug[39m: element rule4 {"type":"Chunk","value":" to ","text":" to [{","offset":2436,"lineBreaks":0,"line":33,"col":70}
14:35:58 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2442,"lineBreaks":0,"line":33,"col":76}}
14:35:58 - [34mdebug[39m: element rule6 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2450,"lineBreaks":0,"line":33,"col":84}
14:35:58 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "22610d77-7de8-4893-a8b1-ff55069e8aed",
        buyer : rule3,
        seller : rule5,
        initialAmount : rule1,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. Sözleşmenin Konusu\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n2. Ödeme Emrinin Alınma Zamanı\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n3. Ödemenin Gerçekleştirilmesi\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n4. Ödeme Hizmetine İlişkin Ücret\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n5. Ödeme İşlemlerine İlişkin Bilgilendirme\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n6. An initial payment of " 


rule1 -> MonetaryAmount {% id %} # initialAmount 


rule2 -> " shall be made by " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> " to " 


rule5 -> AccordParty {% id %} # seller 


rule6 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:35:58 - [34mdebug[39m: fromDirectory
14:35:58 - [34mdebug[39m: fromDirectory
14:35:58 - [31merror[39m: invalid syntax at line 5 col 4:

  1. Taraflar
     ^
Unexpected "T"

Error: invalid syntax at line 5 col 4:

  1. Taraflar
     ^
Unexpected "T"

    at Parser.feed (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/nearley/lib/nearley.js:317:27)
    at Clause.parse (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-core/lib/templateinstance.js:96:16)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:54:24)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
14:35:58 - [32minfo[39m: undefined
14:38:16 - [32minfo[39m: Using current directory as template folder
14:38:16 - [32minfo[39m: Loading a default sample.txt file.
14:38:16 - [34mdebug[39m: fromDirectory
14:38:16 - [34mdebug[39m: fromDirectory
14:38:16 - [34mdebug[39m: fromDirectory
14:38:16 - [34mdebug[39m: fromDirectory
14:38:16 - [34mdebug[39m: fromDirectory
14:38:16 - [34mdebug[39m: fromDirectory
14:38:16 - [34mdebug[39m: fromDirectory
14:38:16 - [34mdebug[39m: constructor
14:38:16 - [34mdebug[39m: constructor
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processDirectory
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: fromDirectory
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:16 - [34mdebug[39m: isFileInNodeModuleDir
14:38:16 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: fromDirectory
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processDirectory
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: fromDirectory
14:38:18 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:38:18 - [34mdebug[39m: fromDirectory
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: isFileInNodeModuleDir
14:38:18 - [34mdebug[39m: processFile
14:38:18 - [34mdebug[39m: fromDirectory
14:38:18 - [34mdebug[39m: buildGrammar
14:38:18 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2452,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2467,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2487,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2494,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2500,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2508,"lineBreaks":0,"line":38,"col":84}]}
14:38:18 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:38:18 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:38:18 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:38:18 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:38:18 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:38:18 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2452,"lineBreaks":0,"line":38,"col":28}}
14:38:18 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2467,"lineBreaks":0,"line":38,"col":43}
14:38:18 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2487,"lineBreaks":0,"line":38,"col":63}}
14:38:18 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2494,"lineBreaks":0,"line":38,"col":70}
14:38:18 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2500,"lineBreaks":0,"line":38,"col":76}}
14:38:18 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2508,"lineBreaks":0,"line":38,"col":84}
14:38:18 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "cd625d0d-94bb-42d9-9d39-b9b0cacbd9dd",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        3.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        3.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        5.1. Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:38:19 - [34mdebug[39m: fromDirectory
14:38:19 - [34mdebug[39m: fromDirectory
14:38:19 - [31merror[39m: invalid syntax at line 23 col 9:

          4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri
          ^
Unexpected "4"

Error: invalid syntax at line 23 col 9:

          4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri
          ^
Unexpected "4"

    at Parser.feed (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/nearley/lib/nearley.js:317:27)
    at Clause.parse (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-core/lib/templateinstance.js:96:16)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:54:24)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
14:38:19 - [32minfo[39m: undefined
14:39:06 - [32minfo[39m: Using current directory as template folder
14:39:06 - [32minfo[39m: Loading a default sample.txt file.
14:39:06 - [34mdebug[39m: fromDirectory
14:39:06 - [34mdebug[39m: fromDirectory
14:39:06 - [34mdebug[39m: fromDirectory
14:39:06 - [34mdebug[39m: fromDirectory
14:39:06 - [34mdebug[39m: fromDirectory
14:39:06 - [34mdebug[39m: fromDirectory
14:39:06 - [34mdebug[39m: fromDirectory
14:39:06 - [34mdebug[39m: constructor
14:39:06 - [34mdebug[39m: constructor
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processDirectory
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: fromDirectory
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:06 - [34mdebug[39m: isFileInNodeModuleDir
14:39:06 - [34mdebug[39m: processFile
14:39:08 - [34mdebug[39m: fromDirectory
14:39:08 - [34mdebug[39m: isFileInNodeModuleDir
14:39:08 - [34mdebug[39m: isFileInNodeModuleDir
14:39:08 - [34mdebug[39m: isFileInNodeModuleDir
14:39:08 - [34mdebug[39m: isFileInNodeModuleDir
14:39:08 - [34mdebug[39m: processDirectory
14:39:08 - [34mdebug[39m: isFileInNodeModuleDir
14:39:08 - [34mdebug[39m: processFile
14:39:08 - [34mdebug[39m: isFileInNodeModuleDir
14:39:08 - [34mdebug[39m: processFile
14:39:08 - [34mdebug[39m: isFileInNodeModuleDir
14:39:08 - [34mdebug[39m: processFile
14:39:08 - [34mdebug[39m: isFileInNodeModuleDir
14:39:08 - [34mdebug[39m: processFile
14:39:08 - [34mdebug[39m: fromDirectory
14:39:09 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:39:09 - [34mdebug[39m: fromDirectory
14:39:09 - [34mdebug[39m: isFileInNodeModuleDir
14:39:09 - [34mdebug[39m: processFile
14:39:09 - [34mdebug[39m: isFileInNodeModuleDir
14:39:09 - [34mdebug[39m: processFile
14:39:09 - [34mdebug[39m: isFileInNodeModuleDir
14:39:09 - [34mdebug[39m: processFile
14:39:09 - [34mdebug[39m: isFileInNodeModuleDir
14:39:09 - [34mdebug[39m: processFile
14:39:09 - [34mdebug[39m: isFileInNodeModuleDir
14:39:09 - [34mdebug[39m: processFile
14:39:09 - [34mdebug[39m: isFileInNodeModuleDir
14:39:09 - [34mdebug[39m: processFile
14:39:09 - [34mdebug[39m: fromDirectory
14:39:09 - [34mdebug[39m: buildGrammar
14:39:09 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2447,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2462,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2482,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2489,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2495,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2503,"lineBreaks":0,"line":38,"col":84}]}
14:39:09 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:39:09 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:39:09 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:39:09 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:39:09 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:39:09 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2447,"lineBreaks":0,"line":38,"col":28}}
14:39:09 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2462,"lineBreaks":0,"line":38,"col":43}
14:39:09 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2482,"lineBreaks":0,"line":38,"col":63}}
14:39:09 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2489,"lineBreaks":0,"line":38,"col":70}
14:39:09 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2495,"lineBreaks":0,"line":38,"col":76}}
14:39:09 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2503,"lineBreaks":0,"line":38,"col":84}
14:39:09 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "993e0255-9939-47f4-8fa9-2e021768b9d5",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya \" \" TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:39:09 - [34mdebug[39m: fromDirectory
14:39:09 - [34mdebug[39m: fromDirectory
14:39:09 - [31merror[39m: invalid syntax at line 31 col 140:

          Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya [ ] TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.
                                                                                                                                             ^
Unexpected "["

Error: invalid syntax at line 31 col 140:

          Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya [ ] TL (EUR/USD) / ücret ödemeyi kabul ve taahhüt eder.
                                                                                                                                             ^
Unexpected "["

    at Parser.feed (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/nearley/lib/nearley.js:317:27)
    at Clause.parse (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-core/lib/templateinstance.js:96:16)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:54:24)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
14:39:09 - [32minfo[39m: undefined
14:39:49 - [32minfo[39m: Using current directory as template folder
14:39:49 - [32minfo[39m: Loading a default sample.txt file.
14:39:49 - [34mdebug[39m: fromDirectory
14:39:49 - [34mdebug[39m: fromDirectory
14:39:49 - [34mdebug[39m: fromDirectory
14:39:49 - [34mdebug[39m: fromDirectory
14:39:49 - [34mdebug[39m: fromDirectory
14:39:49 - [34mdebug[39m: fromDirectory
14:39:49 - [34mdebug[39m: fromDirectory
14:39:49 - [34mdebug[39m: constructor
14:39:49 - [34mdebug[39m: constructor
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processDirectory
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: fromDirectory
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:49 - [34mdebug[39m: isFileInNodeModuleDir
14:39:49 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: fromDirectory
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processDirectory
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: fromDirectory
14:39:52 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:39:52 - [34mdebug[39m: fromDirectory
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: isFileInNodeModuleDir
14:39:52 - [34mdebug[39m: processFile
14:39:52 - [34mdebug[39m: fromDirectory
14:39:52 - [34mdebug[39m: buildGrammar
14:39:52 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:39:52 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:39:52 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:39:52 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:39:52 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:39:52 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:39:52 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:39:52 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:39:52 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:39:52 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:39:52 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:39:52 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:39:52 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "cb9db88d-3865-4e4f-b67a-10b80cf8b68a",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:39:52 - [34mdebug[39m: fromDirectory
14:39:52 - [34mdebug[39m: fromDirectory
14:39:52 - [31merror[39m: invalid syntax at line 31 col 140:

          Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.
                                                                                                                                             ^
Unexpected "ü"

Error: invalid syntax at line 31 col 140:

          Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.
                                                                                                                                             ^
Unexpected "ü"

    at Parser.feed (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/nearley/lib/nearley.js:317:27)
    at Clause.parse (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-core/lib/templateinstance.js:96:16)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:54:24)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
14:39:52 - [32minfo[39m: undefined
14:40:28 - [32minfo[39m: Using current directory as template folder
14:40:28 - [32minfo[39m: Loading a default sample.txt file.
14:40:28 - [34mdebug[39m: fromDirectory
14:40:28 - [34mdebug[39m: fromDirectory
14:40:28 - [34mdebug[39m: fromDirectory
14:40:28 - [34mdebug[39m: fromDirectory
14:40:28 - [34mdebug[39m: fromDirectory
14:40:28 - [34mdebug[39m: fromDirectory
14:40:28 - [34mdebug[39m: fromDirectory
14:40:28 - [34mdebug[39m: constructor
14:40:28 - [34mdebug[39m: constructor
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processDirectory
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: fromDirectory
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:28 - [34mdebug[39m: isFileInNodeModuleDir
14:40:28 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: fromDirectory
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processDirectory
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: fromDirectory
14:40:31 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:40:31 - [34mdebug[39m: fromDirectory
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: isFileInNodeModuleDir
14:40:31 - [34mdebug[39m: processFile
14:40:31 - [34mdebug[39m: fromDirectory
14:40:31 - [34mdebug[39m: buildGrammar
14:40:31 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:40:31 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:40:31 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:40:31 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:40:31 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:40:31 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:40:31 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:40:31 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:40:31 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:40:31 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:40:31 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:40:31 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:40:31 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "509ce7c9-374f-4420-b03f-827bdb6d1b62",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:40:31 - [34mdebug[39m: fromDirectory
14:40:31 - [34mdebug[39m: fromDirectory
14:40:31 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"509ce7c9-374f-4420-b03f-827bdb6d1b62","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:40:31 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"509ce7c9-374f-4420-b03f-827bdb6d1b62","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:40:31 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35m509ce7c9-374f-4420-b03f-827bdb6d1b62[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mJohn Doe[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Bank[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
  [33m}[39m
[33m}[39m
14:42:54 - [32minfo[39m: Using current directory as template folder
14:42:54 - [32minfo[39m: Loading a default sample.txt file.
14:42:54 - [32minfo[39m: Loading a single default request.json file.
14:42:54 - [32minfo[39m: Loading a default state.json file.
14:42:54 - [34mdebug[39m: fromDirectory
14:42:54 - [34mdebug[39m: fromDirectory
14:42:54 - [34mdebug[39m: fromDirectory
14:42:54 - [34mdebug[39m: fromDirectory
14:42:54 - [34mdebug[39m: fromDirectory
14:42:54 - [34mdebug[39m: fromDirectory
14:42:54 - [34mdebug[39m: fromDirectory
14:42:54 - [34mdebug[39m: constructor
14:42:54 - [34mdebug[39m: constructor
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processDirectory
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: fromDirectory
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:54 - [34mdebug[39m: isFileInNodeModuleDir
14:42:54 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: fromDirectory
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processDirectory
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: fromDirectory
14:42:56 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:42:56 - [34mdebug[39m: fromDirectory
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: isFileInNodeModuleDir
14:42:56 - [34mdebug[39m: processFile
14:42:56 - [34mdebug[39m: fromDirectory
14:42:56 - [34mdebug[39m: buildGrammar
14:42:56 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:42:56 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:42:56 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:42:56 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:42:56 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:42:56 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:42:56 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:42:56 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:42:56 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:42:56 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:42:56 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:42:56 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:42:56 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "8c4e424b-c7c0-47f1-9f31-ad068b841489",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:42:57 - [34mdebug[39m: fromDirectory
14:42:57 - [34mdebug[39m: fromDirectory
14:42:57 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"8c4e424b-c7c0-47f1-9f31-ad068b841489","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:42:57 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"8c4e424b-c7c0-47f1-9f31-ad068b841489","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:42:57 - [31merror[39m: Namespace is not defined for type org.accordproject.payment.onetime.InitRequest
TypeNotFoundException: Namespace is not defined for type org.accordproject.payment.onetime.InitRequest
    at ModelManager.getType (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/composer-common/lib/modelmanager.js:445:19)
    at Serializer.fromJSON (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/composer-common/lib/serializer.js:146:52)
    at Engine.execute (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-engine/lib/engine.js:203:55)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:151:45)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
14:42:57 - [32minfo[39m: undefined
14:45:44 - [32minfo[39m: Using current directory as template folder
14:45:44 - [32minfo[39m: Loading a default sample.txt file.
14:45:44 - [32minfo[39m: Loading a single default request.json file.
14:45:44 - [32minfo[39m: Loading a default state.json file.
14:45:44 - [34mdebug[39m: fromDirectory
14:45:44 - [34mdebug[39m: fromDirectory
14:45:44 - [34mdebug[39m: fromDirectory
14:45:44 - [34mdebug[39m: fromDirectory
14:45:44 - [34mdebug[39m: fromDirectory
14:45:44 - [34mdebug[39m: fromDirectory
14:45:44 - [34mdebug[39m: fromDirectory
14:45:44 - [34mdebug[39m: constructor
14:45:44 - [34mdebug[39m: constructor
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processDirectory
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: fromDirectory
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:44 - [34mdebug[39m: isFileInNodeModuleDir
14:45:44 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: fromDirectory
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processDirectory
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: fromDirectory
14:45:47 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:45:47 - [34mdebug[39m: fromDirectory
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: isFileInNodeModuleDir
14:45:47 - [34mdebug[39m: processFile
14:45:47 - [34mdebug[39m: fromDirectory
14:45:47 - [34mdebug[39m: buildGrammar
14:45:47 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:45:47 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:45:47 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:45:47 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:45:47 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:45:47 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:45:47 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:45:47 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:45:47 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:45:47 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:45:47 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:45:47 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:45:47 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "340ce6b5-6b7d-4144-a467-7fcbc47814b2",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:45:47 - [34mdebug[39m: fromDirectory
14:45:47 - [34mdebug[39m: fromDirectory
14:45:47 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"340ce6b5-6b7d-4144-a467-7fcbc47814b2","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:45:47 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"340ce6b5-6b7d-4144-a467-7fcbc47814b2","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:45:47 - [31merror[39m: Namespace is not defined for type org.accordproject.payment.onetime.InitRequest
TypeNotFoundException: Namespace is not defined for type org.accordproject.payment.onetime.InitRequest
    at ModelManager.getType (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/composer-common/lib/modelmanager.js:445:19)
    at Serializer.fromJSON (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/composer-common/lib/serializer.js:146:52)
    at Engine.execute (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-engine/lib/engine.js:203:55)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:151:45)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
14:45:47 - [32minfo[39m: undefined
14:47:59 - [32minfo[39m: Using current directory as template folder
14:47:59 - [32minfo[39m: Loading a default sample.txt file.
14:47:59 - [34mdebug[39m: fromDirectory
14:47:59 - [34mdebug[39m: fromDirectory
14:47:59 - [34mdebug[39m: fromDirectory
14:47:59 - [34mdebug[39m: fromDirectory
14:47:59 - [34mdebug[39m: fromDirectory
14:47:59 - [34mdebug[39m: fromDirectory
14:47:59 - [34mdebug[39m: fromDirectory
14:47:59 - [34mdebug[39m: constructor
14:47:59 - [34mdebug[39m: constructor
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processDirectory
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: fromDirectory
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:47:59 - [34mdebug[39m: isFileInNodeModuleDir
14:47:59 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: fromDirectory
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processDirectory
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: fromDirectory
14:48:12 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:48:12 - [34mdebug[39m: fromDirectory
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: isFileInNodeModuleDir
14:48:12 - [34mdebug[39m: processFile
14:48:12 - [34mdebug[39m: fromDirectory
14:48:12 - [34mdebug[39m: buildGrammar
14:48:12 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:48:12 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:48:12 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:48:12 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:48:12 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:48:12 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:48:12 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:48:12 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:48:12 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:48:12 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:48:12 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:48:12 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:48:12 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "28e6336e-217d-47d1-b036-a7a749d3ed5a",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:48:12 - [34mdebug[39m: fromDirectory
14:48:12 - [34mdebug[39m: fromDirectory
14:48:12 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"28e6336e-217d-47d1-b036-a7a749d3ed5a","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:48:12 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"28e6336e-217d-47d1-b036-a7a749d3ed5a","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:48:12 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35m28e6336e-217d-47d1-b036-a7a749d3ed5a[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mJohn Doe[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Bank[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
  [33m}[39m
[33m}[39m
14:48:47 - [32minfo[39m: Using current directory as template folder
14:48:47 - [32minfo[39m: Loading a default sample.txt file.
14:48:47 - [32minfo[39m: Loading a single default request.json file.
14:48:47 - [32minfo[39m: Loading a default state.json file.
14:48:47 - [34mdebug[39m: fromDirectory
14:48:47 - [34mdebug[39m: fromDirectory
14:48:47 - [34mdebug[39m: fromDirectory
14:48:47 - [34mdebug[39m: fromDirectory
14:48:47 - [34mdebug[39m: fromDirectory
14:48:47 - [34mdebug[39m: fromDirectory
14:48:47 - [34mdebug[39m: fromDirectory
14:48:47 - [34mdebug[39m: constructor
14:48:47 - [34mdebug[39m: constructor
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processDirectory
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: fromDirectory
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:47 - [34mdebug[39m: isFileInNodeModuleDir
14:48:47 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: fromDirectory
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processDirectory
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: fromDirectory
14:48:51 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXOneTimePayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXOneTimePayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXOneTimePayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:48:51 - [34mdebug[39m: fromDirectory
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: isFileInNodeModuleDir
14:48:51 - [34mdebug[39m: processFile
14:48:51 - [34mdebug[39m: fromDirectory
14:48:51 - [34mdebug[39m: buildGrammar
14:48:51 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:48:51 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:48:51 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:48:51 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:48:51 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:48:51 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:48:51 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:48:51 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:48:51 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:48:51 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:48:51 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:48:51 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:48:51 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "f8ecd589-00f8-4955-b6fc-1f653c0bba0d",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:48:51 - [34mdebug[39m: fromDirectory
14:48:51 - [34mdebug[39m: fromDirectory
14:48:51 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"f8ecd589-00f8-4955-b6fc-1f653c0bba0d","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:48:51 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"f8ecd589-00f8-4955-b6fc-1f653c0bba0d","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:48:51 - [31merror[39m: Namespace is not defined for type org.accordproject.payment.onetime.InitRequest
TypeNotFoundException: Namespace is not defined for type org.accordproject.payment.onetime.InitRequest
    at ModelManager.getType (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/composer-common/lib/modelmanager.js:445:19)
    at Serializer.fromJSON (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/composer-common/lib/serializer.js:146:52)
    at Engine.execute (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-engine/lib/engine.js:203:55)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:151:45)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
14:48:51 - [32minfo[39m: undefined
14:49:58 - [32minfo[39m: Using current directory as template folder
14:49:58 - [32minfo[39m: Loading a default sample.txt file.
14:49:58 - [32minfo[39m: Loading a single default request.json file.
14:49:58 - [32minfo[39m: Loading a default state.json file.
14:49:58 - [34mdebug[39m: fromDirectory
14:49:58 - [34mdebug[39m: fromDirectory
14:49:58 - [34mdebug[39m: fromDirectory
14:49:58 - [34mdebug[39m: fromDirectory
14:49:58 - [34mdebug[39m: fromDirectory
14:49:58 - [34mdebug[39m: fromDirectory
14:49:58 - [34mdebug[39m: fromDirectory
14:49:58 - [34mdebug[39m: constructor
14:49:58 - [34mdebug[39m: constructor
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processDirectory
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: fromDirectory
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:49:58 - [34mdebug[39m: isFileInNodeModuleDir
14:49:58 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: fromDirectory
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processDirectory
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: fromDirectory
14:50:00 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:50:00 - [34mdebug[39m: fromDirectory
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: isFileInNodeModuleDir
14:50:00 - [34mdebug[39m: processFile
14:50:00 - [34mdebug[39m: fromDirectory
14:50:00 - [34mdebug[39m: buildGrammar
14:50:00 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:50:00 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:50:00 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:50:00 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:50:00 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:50:00 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:50:00 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:50:00 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:50:00 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:50:00 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:50:00 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:50:00 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:50:00 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "d77af283-32b3-41f3-a4ee-327aaaeba4aa",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:50:00 - [34mdebug[39m: fromDirectory
14:50:00 - [34mdebug[39m: fromDirectory
14:50:00 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"d77af283-32b3-41f3-a4ee-327aaaeba4aa","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:50:00 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"d77af283-32b3-41f3-a4ee-327aaaeba4aa","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:50:00 - [31merror[39m: Namespace is not defined for type org.accordproject.payment.onetime.InitRequest
TypeNotFoundException: Namespace is not defined for type org.accordproject.payment.onetime.InitRequest
    at ModelManager.getType (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/composer-common/lib/modelmanager.js:445:19)
    at Serializer.fromJSON (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/composer-common/lib/serializer.js:146:52)
    at Engine.execute (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-engine/lib/engine.js:203:55)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:151:45)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
14:50:00 - [32minfo[39m: undefined
14:51:24 - [32minfo[39m: Using current directory as template folder
14:51:24 - [32minfo[39m: Loading a default sample.txt file.
14:51:24 - [32minfo[39m: Loading a single default request.json file.
14:51:24 - [32minfo[39m: Loading a default state.json file.
14:51:24 - [34mdebug[39m: fromDirectory
14:51:24 - [34mdebug[39m: fromDirectory
14:51:24 - [34mdebug[39m: fromDirectory
14:51:24 - [34mdebug[39m: fromDirectory
14:51:24 - [34mdebug[39m: fromDirectory
14:51:24 - [34mdebug[39m: fromDirectory
14:51:24 - [34mdebug[39m: fromDirectory
14:51:24 - [34mdebug[39m: constructor
14:51:24 - [34mdebug[39m: constructor
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processDirectory
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: fromDirectory
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:24 - [34mdebug[39m: isFileInNodeModuleDir
14:51:24 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: fromDirectory
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processDirectory
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: fromDirectory
14:51:27 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:51:27 - [34mdebug[39m: fromDirectory
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: isFileInNodeModuleDir
14:51:27 - [34mdebug[39m: processFile
14:51:27 - [34mdebug[39m: fromDirectory
14:51:27 - [34mdebug[39m: buildGrammar
14:51:27 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:51:27 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:51:27 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:51:27 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:51:27 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:51:27 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:51:27 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:51:27 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:51:27 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:51:27 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:51:27 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:51:27 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:51:27 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "6210f807-4099-4d61-ad41-f26ffcd74efb",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:51:27 - [34mdebug[39m: fromDirectory
14:51:27 - [34mdebug[39m: fromDirectory
14:51:27 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"6210f807-4099-4d61-ad41-f26ffcd74efb","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:51:27 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"6210f807-4099-4d61-ad41-f26ffcd74efb","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:51:27 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
14:51:27 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
14:51:27 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
14:51:27 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-44e49df6500aec6ab10051061d408e64834a0db9fee9c59cea662ffc491bffc6[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35m4646dd0a-1ec2-4fe5-8538-12e04a92a254[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-20T11:51:27.888Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#6210f807-4099-4d61-ad41-f26ffcd74efb[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#John%20Doe[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Bank[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-20T11:51:27.889Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
14:54:40 - [32minfo[39m: Using current directory as template folder
14:54:40 - [32minfo[39m: Loading a default sample.txt file.
14:54:40 - [32minfo[39m: Loading a single default request.json file.
14:54:40 - [32minfo[39m: Loading a default state.json file.
14:54:40 - [34mdebug[39m: fromDirectory
14:54:40 - [34mdebug[39m: fromDirectory
14:54:40 - [34mdebug[39m: fromDirectory
14:54:40 - [34mdebug[39m: fromDirectory
14:54:40 - [34mdebug[39m: fromDirectory
14:54:40 - [34mdebug[39m: fromDirectory
14:54:40 - [34mdebug[39m: fromDirectory
14:54:40 - [34mdebug[39m: constructor
14:54:40 - [34mdebug[39m: constructor
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processDirectory
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: fromDirectory
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:40 - [34mdebug[39m: isFileInNodeModuleDir
14:54:40 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: fromDirectory
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processDirectory
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: fromDirectory
14:54:44 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:54:44 - [34mdebug[39m: fromDirectory
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: isFileInNodeModuleDir
14:54:44 - [34mdebug[39m: processFile
14:54:44 - [34mdebug[39m: fromDirectory
14:54:44 - [34mdebug[39m: buildGrammar
14:54:44 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:54:44 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:54:44 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:54:44 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:54:44 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:54:44 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:54:44 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:54:44 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:54:44 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:54:44 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:54:44 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:54:44 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:54:44 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "65541e43-64ee-4ff4-aeb7-1d080454ec09",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:54:44 - [34mdebug[39m: fromDirectory
14:54:44 - [34mdebug[39m: fromDirectory
14:54:44 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"65541e43-64ee-4ff4-aeb7-1d080454ec09","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:54:44 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"65541e43-64ee-4ff4-aeb7-1d080454ec09","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:54:44 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
14:54:44 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
14:54:44 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
14:54:44 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-a40073bf23b89b4672119227dae83a0396a9d2537fbbbf60d8f93a6554fa733b[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35mc830c159-4eb8-4c10-853b-a8e5fc94896a[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-20T11:54:44.833Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#65541e43-64ee-4ff4-aeb7-1d080454ec09[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#John%20Doe[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Bank[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-20T11:54:44.833Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
14:55:31 - [32minfo[39m: Using current directory as template folder
14:55:31 - [32minfo[39m: Loading a default sample.txt file.
14:55:31 - [34mdebug[39m: fromDirectory
14:55:31 - [34mdebug[39m: fromDirectory
14:55:31 - [34mdebug[39m: fromDirectory
14:55:31 - [34mdebug[39m: fromDirectory
14:55:31 - [34mdebug[39m: fromDirectory
14:55:31 - [34mdebug[39m: fromDirectory
14:55:31 - [34mdebug[39m: fromDirectory
14:55:31 - [34mdebug[39m: constructor
14:55:31 - [34mdebug[39m: constructor
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processDirectory
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: fromDirectory
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:31 - [34mdebug[39m: isFileInNodeModuleDir
14:55:31 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: fromDirectory
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processDirectory
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: fromDirectory
14:55:35 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:55:35 - [34mdebug[39m: fromDirectory
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: isFileInNodeModuleDir
14:55:35 - [34mdebug[39m: processFile
14:55:35 - [34mdebug[39m: fromDirectory
14:55:35 - [34mdebug[39m: buildGrammar
14:55:35 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:55:35 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:55:35 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:55:35 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:55:35 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:55:35 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:55:35 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:55:35 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:55:35 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:55:35 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:55:35 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:55:35 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:55:35 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "c3f0e8ff-a6d6-4de9-9c12-b020b0b1424a",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:55:35 - [34mdebug[39m: fromDirectory
14:55:35 - [34mdebug[39m: fromDirectory
14:55:35 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"c3f0e8ff-a6d6-4de9-9c12-b020b0b1424a","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:55:35 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"c3f0e8ff-a6d6-4de9-9c12-b020b0b1424a","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:55:35 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35mc3f0e8ff-a6d6-4de9-9c12-b020b0b1424a[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mJohn Doe[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Bank[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
  [33m}[39m
[33m}[39m
14:56:11 - [32minfo[39m: Using current directory as template folder
14:56:11 - [32minfo[39m: Loading a default sample.txt file.
14:56:11 - [32minfo[39m: Loading a single default request.json file.
14:56:11 - [32minfo[39m: Loading a default state.json file.
14:56:11 - [34mdebug[39m: fromDirectory
14:56:11 - [34mdebug[39m: fromDirectory
14:56:11 - [34mdebug[39m: fromDirectory
14:56:11 - [34mdebug[39m: fromDirectory
14:56:11 - [34mdebug[39m: fromDirectory
14:56:11 - [34mdebug[39m: fromDirectory
14:56:11 - [34mdebug[39m: fromDirectory
14:56:11 - [34mdebug[39m: constructor
14:56:11 - [34mdebug[39m: constructor
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processDirectory
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: fromDirectory
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:11 - [34mdebug[39m: isFileInNodeModuleDir
14:56:11 - [34mdebug[39m: processFile
14:56:17 - [34mdebug[39m: fromDirectory
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: processDirectory
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: processFile
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: processFile
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: processFile
14:56:17 - [34mdebug[39m: isFileInNodeModuleDir
14:56:17 - [34mdebug[39m: processFile
14:56:17 - [34mdebug[39m: fromDirectory
14:56:18 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



14:56:18 - [34mdebug[39m: fromDirectory
14:56:18 - [34mdebug[39m: isFileInNodeModuleDir
14:56:18 - [34mdebug[39m: processFile
14:56:18 - [34mdebug[39m: isFileInNodeModuleDir
14:56:18 - [34mdebug[39m: processFile
14:56:18 - [34mdebug[39m: isFileInNodeModuleDir
14:56:18 - [34mdebug[39m: processFile
14:56:18 - [34mdebug[39m: isFileInNodeModuleDir
14:56:18 - [34mdebug[39m: processFile
14:56:18 - [34mdebug[39m: isFileInNodeModuleDir
14:56:18 - [34mdebug[39m: processFile
14:56:18 - [34mdebug[39m: isFileInNodeModuleDir
14:56:18 - [34mdebug[39m: processFile
14:56:18 - [34mdebug[39m: isFileInNodeModuleDir
14:56:18 - [34mdebug[39m: processFile
14:56:18 - [34mdebug[39m: fromDirectory
14:56:18 - [34mdebug[39m: buildGrammar
14:56:18 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
14:56:18 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
14:56:18 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
14:56:18 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
14:56:18 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
14:56:18 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
14:56:18 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
14:56:18 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
14:56:18 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
14:56:18 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
14:56:18 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
14:56:18 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
14:56:18 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "320e2f5b-41e5-4dd8-959d-53f367f7ab90",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
14:56:18 - [34mdebug[39m: fromDirectory
14:56:18 - [34mdebug[39m: fromDirectory
14:56:18 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"320e2f5b-41e5-4dd8-959d-53f367f7ab90","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:56:18 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"320e2f5b-41e5-4dd8-959d-53f367f7ab90","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"John Doe"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Bank"},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
14:56:18 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
14:56:18 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
14:56:18 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
14:56:18 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-56b0aab497be31b741054522fbe0288d07474cdeeb9a8bf31ece5f6a2d724a95[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35m86c4b9ec-2318-4172-9437-20fb5bfd409f[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-20T11:56:18.616Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#320e2f5b-41e5-4dd8-959d-53f367f7ab90[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#John%20Doe[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Bank[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-20T11:56:18.618Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
17:44:12 - [32minfo[39m: Using current directory as template folder
17:44:12 - [32minfo[39m: Loading a default sample.txt file.
17:44:12 - [34mdebug[39m: fromDirectory
17:44:12 - [34mdebug[39m: fromDirectory
17:44:12 - [34mdebug[39m: fromDirectory
17:44:12 - [34mdebug[39m: fromDirectory
17:44:12 - [34mdebug[39m: fromDirectory
17:44:12 - [34mdebug[39m: fromDirectory
17:44:12 - [34mdebug[39m: fromDirectory
17:44:12 - [34mdebug[39m: constructor
17:44:12 - [34mdebug[39m: constructor
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processDirectory
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: fromDirectory
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:12 - [34mdebug[39m: isFileInNodeModuleDir
17:44:12 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: fromDirectory
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processDirectory
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: fromDirectory
17:44:14 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



17:44:14 - [34mdebug[39m: fromDirectory
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: isFileInNodeModuleDir
17:44:14 - [34mdebug[39m: processFile
17:44:14 - [34mdebug[39m: fromDirectory
17:44:14 - [34mdebug[39m: buildGrammar
17:44:14 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
17:44:14 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
17:44:14 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
17:44:14 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
17:44:14 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
17:44:14 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
17:44:14 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
17:44:14 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
17:44:14 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
17:44:14 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
17:44:14 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
17:44:14 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
17:44:14 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "b5c86076-421d-4fbc-86b1-5bb701691644",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
17:44:15 - [34mdebug[39m: fromDirectory
17:44:15 - [34mdebug[39m: fromDirectory
17:44:15 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"b5c86076-421d-4fbc-86b1-5bb701691644","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
17:44:15 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"b5c86076-421d-4fbc-86b1-5bb701691644","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
17:44:15 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35mb5c86076-421d-4fbc-86b1-5bb701691644[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
  [33m}[39m
[33m}[39m
17:44:23 - [32minfo[39m: Using current directory as template folder
17:44:23 - [32minfo[39m: Loading a default sample.txt file.
17:44:23 - [32minfo[39m: Loading a single default request.json file.
17:44:23 - [32minfo[39m: Loading a default state.json file.
17:44:23 - [34mdebug[39m: fromDirectory
17:44:23 - [34mdebug[39m: fromDirectory
17:44:23 - [34mdebug[39m: fromDirectory
17:44:23 - [34mdebug[39m: fromDirectory
17:44:23 - [34mdebug[39m: fromDirectory
17:44:23 - [34mdebug[39m: fromDirectory
17:44:23 - [34mdebug[39m: fromDirectory
17:44:23 - [34mdebug[39m: constructor
17:44:23 - [34mdebug[39m: constructor
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processDirectory
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: fromDirectory
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:23 - [34mdebug[39m: isFileInNodeModuleDir
17:44:23 - [34mdebug[39m: processFile
17:44:27 - [34mdebug[39m: fromDirectory
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: processDirectory
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: processFile
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: processFile
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: processFile
17:44:27 - [34mdebug[39m: isFileInNodeModuleDir
17:44:27 - [34mdebug[39m: processFile
17:44:27 - [34mdebug[39m: fromDirectory
17:44:28 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



17:44:28 - [34mdebug[39m: fromDirectory
17:44:28 - [34mdebug[39m: isFileInNodeModuleDir
17:44:28 - [34mdebug[39m: processFile
17:44:28 - [34mdebug[39m: isFileInNodeModuleDir
17:44:28 - [34mdebug[39m: processFile
17:44:28 - [34mdebug[39m: isFileInNodeModuleDir
17:44:28 - [34mdebug[39m: processFile
17:44:28 - [34mdebug[39m: isFileInNodeModuleDir
17:44:28 - [34mdebug[39m: processFile
17:44:28 - [34mdebug[39m: isFileInNodeModuleDir
17:44:28 - [34mdebug[39m: processFile
17:44:28 - [34mdebug[39m: isFileInNodeModuleDir
17:44:28 - [34mdebug[39m: processFile
17:44:28 - [34mdebug[39m: isFileInNodeModuleDir
17:44:28 - [34mdebug[39m: processFile
17:44:28 - [34mdebug[39m: fromDirectory
17:44:28 - [34mdebug[39m: buildGrammar
17:44:28 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
17:44:28 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
17:44:28 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
17:44:28 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
17:44:28 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
17:44:28 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
17:44:28 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
17:44:28 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
17:44:28 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
17:44:28 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
17:44:28 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
17:44:28 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
17:44:28 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "b0696249-eb6b-4cf5-aa1a-0d1a0cb1f1c7",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
17:44:28 - [34mdebug[39m: fromDirectory
17:44:28 - [34mdebug[39m: fromDirectory
17:44:28 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"b0696249-eb6b-4cf5-aa1a-0d1a0cb1f1c7","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
17:44:28 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"b0696249-eb6b-4cf5-aa1a-0d1a0cb1f1c7","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
17:44:28 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
17:44:28 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
17:44:28 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
17:44:28 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-f108a44514803d4eeecea70e5a7805b9e90040c95edb51f91b3ebe4900ec2807[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35m061c4edd-f6b8-417e-8755-00887768326b[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-23T14:44:28.377Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#b0696249-eb6b-4cf5-aa1a-0d1a0cb1f1c7[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#Can%20Do%C4%9Fan[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Corp.[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-23T14:44:28.378Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
09:01:46 - [32minfo[39m: Using current directory as template folder
09:01:46 - [32minfo[39m: Loading a default sample.txt file.
09:01:46 - [34mdebug[39m: fromDirectory
09:01:46 - [34mdebug[39m: fromDirectory
09:01:46 - [34mdebug[39m: fromDirectory
09:01:46 - [34mdebug[39m: fromDirectory
09:01:46 - [34mdebug[39m: fromDirectory
09:01:46 - [34mdebug[39m: fromDirectory
09:01:46 - [34mdebug[39m: fromDirectory
09:01:46 - [34mdebug[39m: constructor
09:01:46 - [34mdebug[39m: constructor
09:01:46 - [34mdebug[39m: isFileInNodeModuleDir
09:01:46 - [34mdebug[39m: isFileInNodeModuleDir
09:01:46 - [34mdebug[39m: isFileInNodeModuleDir
09:01:46 - [34mdebug[39m: isFileInNodeModuleDir
09:01:46 - [34mdebug[39m: isFileInNodeModuleDir
09:01:46 - [34mdebug[39m: processDirectory
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: fromDirectory
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:47 - [34mdebug[39m: isFileInNodeModuleDir
09:01:47 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: fromDirectory
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processDirectory
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: fromDirectory
09:01:49 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



09:01:49 - [34mdebug[39m: fromDirectory
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: isFileInNodeModuleDir
09:01:49 - [34mdebug[39m: processFile
09:01:49 - [34mdebug[39m: fromDirectory
09:01:49 - [34mdebug[39m: buildGrammar
09:01:49 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
09:01:49 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
09:01:49 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
09:01:49 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
09:01:49 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
09:01:49 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
09:01:49 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
09:01:49 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
09:01:49 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
09:01:49 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
09:01:49 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
09:01:49 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
09:01:49 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "e4f387bd-ef41-49be-9b5f-9fd7585b5657",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
09:01:49 - [34mdebug[39m: fromDirectory
09:01:49 - [34mdebug[39m: fromDirectory
09:01:49 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"e4f387bd-ef41-49be-9b5f-9fd7585b5657","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
09:01:49 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"e4f387bd-ef41-49be-9b5f-9fd7585b5657","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
09:01:49 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35me4f387bd-ef41-49be-9b5f-9fd7585b5657[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
  [33m}[39m
[33m}[39m
09:01:59 - [32minfo[39m: Using current directory as template folder
09:01:59 - [32minfo[39m: Loading a default sample.txt file.
09:01:59 - [32minfo[39m: Loading a single default request.json file.
09:01:59 - [32minfo[39m: Loading a default state.json file.
09:01:59 - [34mdebug[39m: fromDirectory
09:01:59 - [34mdebug[39m: fromDirectory
09:01:59 - [34mdebug[39m: fromDirectory
09:01:59 - [34mdebug[39m: fromDirectory
09:01:59 - [34mdebug[39m: fromDirectory
09:01:59 - [34mdebug[39m: fromDirectory
09:01:59 - [34mdebug[39m: fromDirectory
09:01:59 - [34mdebug[39m: constructor
09:01:59 - [34mdebug[39m: constructor
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processDirectory
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: fromDirectory
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:01:59 - [34mdebug[39m: isFileInNodeModuleDir
09:01:59 - [34mdebug[39m: processFile
09:02:01 - [34mdebug[39m: fromDirectory
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: processDirectory
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: processFile
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: processFile
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: processFile
09:02:01 - [34mdebug[39m: isFileInNodeModuleDir
09:02:01 - [34mdebug[39m: processFile
09:02:01 - [34mdebug[39m: fromDirectory
09:02:02 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



09:02:02 - [34mdebug[39m: fromDirectory
09:02:02 - [34mdebug[39m: isFileInNodeModuleDir
09:02:02 - [34mdebug[39m: processFile
09:02:02 - [34mdebug[39m: isFileInNodeModuleDir
09:02:02 - [34mdebug[39m: processFile
09:02:02 - [34mdebug[39m: isFileInNodeModuleDir
09:02:02 - [34mdebug[39m: processFile
09:02:02 - [34mdebug[39m: isFileInNodeModuleDir
09:02:02 - [34mdebug[39m: processFile
09:02:02 - [34mdebug[39m: isFileInNodeModuleDir
09:02:02 - [34mdebug[39m: processFile
09:02:02 - [34mdebug[39m: isFileInNodeModuleDir
09:02:02 - [34mdebug[39m: processFile
09:02:02 - [34mdebug[39m: isFileInNodeModuleDir
09:02:02 - [34mdebug[39m: processFile
09:02:02 - [34mdebug[39m: fromDirectory
09:02:02 - [34mdebug[39m: buildGrammar
09:02:02 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
09:02:02 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
09:02:02 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
09:02:02 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
09:02:02 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
09:02:02 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
09:02:02 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
09:02:02 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
09:02:02 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
09:02:02 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
09:02:02 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
09:02:02 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
09:02:02 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "afbd54ce-4ce6-493d-8105-823efb9ecac9",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
09:02:02 - [34mdebug[39m: fromDirectory
09:02:02 - [34mdebug[39m: fromDirectory
09:02:02 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"afbd54ce-4ce6-493d-8105-823efb9ecac9","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
09:02:02 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"afbd54ce-4ce6-493d-8105-823efb9ecac9","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
09:02:02 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
09:02:02 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
09:02:02 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
09:02:02 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-21c01ed1933391135d06556464d7bc232ac97147382839a0f4c33eb3719eb86a[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35m6b5ae768-d7c1-40e4-80bd-dcc2134f781e[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-26T06:02:02.403Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#afbd54ce-4ce6-493d-8105-823efb9ecac9[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#Can%20Do%C4%9Fan[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Corp.[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-26T06:02:02.404Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
16:34:15 - [32minfo[39m: Using current directory as template folder
16:34:15 - [32minfo[39m: Loading a default sample.txt file.
16:34:15 - [34mdebug[39m: fromDirectory
16:34:15 - [34mdebug[39m: fromDirectory
16:34:15 - [34mdebug[39m: fromDirectory
16:34:15 - [34mdebug[39m: fromDirectory
16:34:15 - [34mdebug[39m: fromDirectory
16:34:15 - [34mdebug[39m: fromDirectory
16:34:15 - [34mdebug[39m: fromDirectory
16:34:15 - [34mdebug[39m: constructor
16:34:15 - [34mdebug[39m: constructor
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processDirectory
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: fromDirectory
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:15 - [34mdebug[39m: isFileInNodeModuleDir
16:34:15 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: fromDirectory
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processDirectory
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: fromDirectory
16:34:20 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



16:34:20 - [34mdebug[39m: fromDirectory
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: isFileInNodeModuleDir
16:34:20 - [34mdebug[39m: processFile
16:34:20 - [34mdebug[39m: fromDirectory
16:34:20 - [34mdebug[39m: buildGrammar
16:34:20 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
16:34:20 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
16:34:20 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
16:34:20 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
16:34:20 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
16:34:20 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
16:34:20 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
16:34:20 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
16:34:20 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
16:34:20 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
16:34:20 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
16:34:20 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
16:34:20 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "a3603844-baee-48c2-b61a-38ce89068cd6",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
16:34:20 - [34mdebug[39m: fromDirectory
16:34:20 - [34mdebug[39m: fromDirectory
16:34:20 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"a3603844-baee-48c2-b61a-38ce89068cd6","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
16:34:20 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"a3603844-baee-48c2-b61a-38ce89068cd6","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
16:34:20 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35ma3603844-baee-48c2-b61a-38ce89068cd6[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
  [33m}[39m
[33m}[39m
16:34:31 - [32minfo[39m: Using current directory as template folder
16:34:31 - [32minfo[39m: Loading a default sample.txt file.
16:34:31 - [32minfo[39m: Loading a single default request.json file.
16:34:31 - [32minfo[39m: Loading a default state.json file.
16:34:31 - [34mdebug[39m: fromDirectory
16:34:31 - [34mdebug[39m: fromDirectory
16:34:31 - [34mdebug[39m: fromDirectory
16:34:31 - [34mdebug[39m: fromDirectory
16:34:31 - [34mdebug[39m: fromDirectory
16:34:31 - [34mdebug[39m: fromDirectory
16:34:31 - [34mdebug[39m: fromDirectory
16:34:31 - [34mdebug[39m: constructor
16:34:31 - [34mdebug[39m: constructor
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processDirectory
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: fromDirectory
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:31 - [34mdebug[39m: isFileInNodeModuleDir
16:34:31 - [34mdebug[39m: processFile
16:34:33 - [34mdebug[39m: fromDirectory
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: processDirectory
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: processFile
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: processFile
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: processFile
16:34:33 - [34mdebug[39m: isFileInNodeModuleDir
16:34:33 - [34mdebug[39m: processFile
16:34:33 - [34mdebug[39m: fromDirectory
16:34:34 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



16:34:34 - [34mdebug[39m: fromDirectory
16:34:34 - [34mdebug[39m: isFileInNodeModuleDir
16:34:34 - [34mdebug[39m: processFile
16:34:34 - [34mdebug[39m: isFileInNodeModuleDir
16:34:34 - [34mdebug[39m: processFile
16:34:34 - [34mdebug[39m: isFileInNodeModuleDir
16:34:34 - [34mdebug[39m: processFile
16:34:34 - [34mdebug[39m: isFileInNodeModuleDir
16:34:34 - [34mdebug[39m: processFile
16:34:34 - [34mdebug[39m: isFileInNodeModuleDir
16:34:34 - [34mdebug[39m: processFile
16:34:34 - [34mdebug[39m: isFileInNodeModuleDir
16:34:34 - [34mdebug[39m: processFile
16:34:34 - [34mdebug[39m: isFileInNodeModuleDir
16:34:34 - [34mdebug[39m: processFile
16:34:34 - [34mdebug[39m: fromDirectory
16:34:34 - [34mdebug[39m: buildGrammar
16:34:34 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
16:34:34 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
16:34:34 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
16:34:34 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
16:34:34 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
16:34:34 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
16:34:34 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
16:34:34 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
16:34:34 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
16:34:34 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
16:34:34 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
16:34:34 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
16:34:34 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "84a8745a-22e2-4a4e-8fff-26f79e05e9e5",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
16:34:34 - [34mdebug[39m: fromDirectory
16:34:34 - [34mdebug[39m: fromDirectory
16:34:34 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"84a8745a-22e2-4a4e-8fff-26f79e05e9e5","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
16:34:34 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"84a8745a-22e2-4a4e-8fff-26f79e05e9e5","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
16:34:34 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
16:34:34 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
16:34:34 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
16:34:34 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-3a25a9016c3484a683c43e63c714d0b245ba8c556391666de5821f08d05da87f[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35m96116977-5e13-4d43-ab85-de6d6986e687[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-26T13:34:34.487Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#84a8745a-22e2-4a4e-8fff-26f79e05e9e5[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#Can%20Do%C4%9Fan[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Corp.[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-26T13:34:34.488Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
13:31:43 - [32minfo[39m: Using current directory as template folder
13:31:43 - [32minfo[39m: Loading a default sample.txt file.
13:31:43 - [34mdebug[39m: fromDirectory
13:31:43 - [34mdebug[39m: fromDirectory
13:31:43 - [34mdebug[39m: fromDirectory
13:31:43 - [34mdebug[39m: fromDirectory
13:31:43 - [34mdebug[39m: fromDirectory
13:31:43 - [34mdebug[39m: fromDirectory
13:31:43 - [34mdebug[39m: fromDirectory
13:31:43 - [34mdebug[39m: constructor
13:31:43 - [34mdebug[39m: constructor
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processDirectory
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: fromDirectory
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:43 - [34mdebug[39m: isFileInNodeModuleDir
13:31:43 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: fromDirectory
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processDirectory
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: fromDirectory
13:31:46 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



13:31:46 - [34mdebug[39m: fromDirectory
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: isFileInNodeModuleDir
13:31:46 - [34mdebug[39m: processFile
13:31:46 - [34mdebug[39m: fromDirectory
13:31:46 - [34mdebug[39m: buildGrammar
13:31:46 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
13:31:46 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
13:31:46 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
13:31:46 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
13:31:46 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
13:31:46 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
13:31:46 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
13:31:46 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
13:31:46 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
13:31:46 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
13:31:46 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
13:31:46 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
13:31:46 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "646c4e44-7526-416e-9119-f12fbb869e85",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
13:31:46 - [34mdebug[39m: fromDirectory
13:31:46 - [34mdebug[39m: fromDirectory
13:31:46 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"646c4e44-7526-416e-9119-f12fbb869e85","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
13:31:46 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"646c4e44-7526-416e-9119-f12fbb869e85","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
13:31:46 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35m646c4e44-7526-416e-9119-f12fbb869e85[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
  [33m}[39m
[33m}[39m
13:31:56 - [32minfo[39m: Using current directory as template folder
13:31:56 - [32minfo[39m: Loading a default sample.txt file.
13:31:56 - [32minfo[39m: Loading a single default request.json file.
13:31:56 - [32minfo[39m: Loading a default state.json file.
13:31:56 - [34mdebug[39m: fromDirectory
13:31:56 - [34mdebug[39m: fromDirectory
13:31:56 - [34mdebug[39m: fromDirectory
13:31:56 - [34mdebug[39m: fromDirectory
13:31:56 - [34mdebug[39m: fromDirectory
13:31:56 - [34mdebug[39m: fromDirectory
13:31:56 - [34mdebug[39m: fromDirectory
13:31:56 - [34mdebug[39m: constructor
13:31:56 - [34mdebug[39m: constructor
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processDirectory
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: fromDirectory
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:56 - [34mdebug[39m: isFileInNodeModuleDir
13:31:56 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: fromDirectory
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processDirectory
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: fromDirectory
13:31:58 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



13:31:58 - [34mdebug[39m: fromDirectory
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: isFileInNodeModuleDir
13:31:58 - [34mdebug[39m: processFile
13:31:58 - [34mdebug[39m: fromDirectory
13:31:58 - [34mdebug[39m: buildGrammar
13:31:58 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
13:31:58 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
13:31:58 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
13:31:58 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
13:31:58 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
13:31:58 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
13:31:58 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
13:31:58 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
13:31:58 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
13:31:58 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
13:31:58 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
13:31:58 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
13:31:58 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "b2db5156-e20f-4bea-ba6a-c2f31ec5808f",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
13:31:58 - [34mdebug[39m: fromDirectory
13:31:58 - [34mdebug[39m: fromDirectory
13:31:58 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"b2db5156-e20f-4bea-ba6a-c2f31ec5808f","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
13:31:58 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"b2db5156-e20f-4bea-ba6a-c2f31ec5808f","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":0.01,"currencyCode":"USD"}}
13:31:58 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
13:31:58 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
13:31:58 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
13:31:58 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-3b7ba0ba538b71db15a0bb865572a4365435e068d45a3cb74f3c04b24741c46e[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35mc020c0ae-bf47-46c6-89f2-265c0687365d[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-30T10:31:58.766Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m0.01[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#b2db5156-e20f-4bea-ba6a-c2f31ec5808f[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#Can%20Do%C4%9Fan[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Corp.[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-30T10:31:58.767Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
11:42:17 - [32minfo[39m: Using current directory as template folder
11:42:17 - [32minfo[39m: Loading a default sample.txt file.
11:42:17 - [34mdebug[39m: fromDirectory
11:42:17 - [34mdebug[39m: fromDirectory
11:42:17 - [34mdebug[39m: fromDirectory
11:42:17 - [34mdebug[39m: fromDirectory
11:42:17 - [34mdebug[39m: fromDirectory
11:42:17 - [34mdebug[39m: fromDirectory
11:42:17 - [34mdebug[39m: fromDirectory
11:42:17 - [34mdebug[39m: constructor
11:42:17 - [34mdebug[39m: constructor
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processDirectory
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: fromDirectory
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:17 - [34mdebug[39m: isFileInNodeModuleDir
11:42:17 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: fromDirectory
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processDirectory
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: fromDirectory
11:42:20 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:42:20 - [34mdebug[39m: fromDirectory
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: isFileInNodeModuleDir
11:42:20 - [34mdebug[39m: processFile
11:42:20 - [34mdebug[39m: fromDirectory
11:42:20 - [34mdebug[39m: buildGrammar
11:42:20 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:42:20 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:42:20 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:42:20 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:42:20 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:42:20 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:42:20 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:42:20 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:42:20 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:42:20 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:42:20 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:42:20 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:42:20 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "39881eaf-1cd0-4c5b-90ee-764f6f2cc9cf",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:42:20 - [34mdebug[39m: fromDirectory
11:42:20 - [34mdebug[39m: fromDirectory
11:42:20 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"39881eaf-1cd0-4c5b-90ee-764f6f2cc9cf","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.01,"currencyCode":"USD"}}
11:42:20 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"39881eaf-1cd0-4c5b-90ee-764f6f2cc9cf","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.01,"currencyCode":"USD"}}
11:42:20 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35m39881eaf-1cd0-4c5b-90ee-764f6f2cc9cf[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mUSD[39m[33m"[39m
  [33m}[39m
[33m}[39m
11:43:21 - [32minfo[39m: Using current directory as template folder
11:43:21 - [32minfo[39m: Loading a default sample.txt file.
11:43:21 - [34mdebug[39m: fromDirectory
11:43:21 - [34mdebug[39m: fromDirectory
11:43:21 - [34mdebug[39m: fromDirectory
11:43:21 - [34mdebug[39m: fromDirectory
11:43:21 - [34mdebug[39m: fromDirectory
11:43:21 - [34mdebug[39m: fromDirectory
11:43:21 - [34mdebug[39m: fromDirectory
11:43:22 - [34mdebug[39m: constructor
11:43:22 - [34mdebug[39m: constructor
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processDirectory
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: fromDirectory
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:22 - [34mdebug[39m: isFileInNodeModuleDir
11:43:22 - [34mdebug[39m: processFile
11:43:23 - [34mdebug[39m: fromDirectory
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: processDirectory
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: processFile
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: processFile
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: processFile
11:43:23 - [34mdebug[39m: isFileInNodeModuleDir
11:43:23 - [34mdebug[39m: processFile
11:43:23 - [34mdebug[39m: fromDirectory
11:43:24 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:43:24 - [34mdebug[39m: fromDirectory
11:43:24 - [34mdebug[39m: isFileInNodeModuleDir
11:43:24 - [34mdebug[39m: processFile
11:43:24 - [34mdebug[39m: isFileInNodeModuleDir
11:43:24 - [34mdebug[39m: processFile
11:43:24 - [34mdebug[39m: isFileInNodeModuleDir
11:43:24 - [34mdebug[39m: processFile
11:43:24 - [34mdebug[39m: isFileInNodeModuleDir
11:43:24 - [34mdebug[39m: processFile
11:43:24 - [34mdebug[39m: isFileInNodeModuleDir
11:43:24 - [34mdebug[39m: processFile
11:43:24 - [34mdebug[39m: isFileInNodeModuleDir
11:43:24 - [34mdebug[39m: processFile
11:43:24 - [34mdebug[39m: isFileInNodeModuleDir
11:43:24 - [34mdebug[39m: processFile
11:43:24 - [34mdebug[39m: fromDirectory
11:43:24 - [34mdebug[39m: buildGrammar
11:43:24 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:43:24 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:43:24 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:43:24 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:43:24 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:43:24 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:43:24 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:43:24 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:43:24 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:43:24 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:43:24 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:43:24 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:43:24 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "43e4f7be-f8c6-4a83-bf3f-1391af7ec1bf",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:43:24 - [34mdebug[39m: fromDirectory
11:43:24 - [34mdebug[39m: fromDirectory
11:43:24 - [31merror[39m: invalid syntax at line 38 col 36:

  7. An initial payment of 1922.01 TRL shall be made by "Umut" to "Serkan" upon execution of this Agreement.
                                     ^
Unexpected "L"

Error: invalid syntax at line 38 col 36:

  7. An initial payment of 1922.01 TRL shall be made by "Umut" to "Serkan" upon execution of this Agreement.
                                     ^
Unexpected "L"

    at Parser.feed (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/nearley/lib/nearley.js:317:27)
    at Clause.parse (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/node_modules/@accordproject/cicero-core/lib/templateinstance.js:96:16)
    at Template.fromDirectory.then (/Users/serkanerkan/.nvm/versions/node/v8.9.4/lib/node_modules/@accordproject/cicero-cli/lib/commands.js:54:24)
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
11:43:24 - [32minfo[39m: undefined
11:43:49 - [32minfo[39m: Using current directory as template folder
11:43:49 - [32minfo[39m: Loading a default sample.txt file.
11:43:49 - [34mdebug[39m: fromDirectory
11:43:49 - [34mdebug[39m: fromDirectory
11:43:49 - [34mdebug[39m: fromDirectory
11:43:49 - [34mdebug[39m: fromDirectory
11:43:49 - [34mdebug[39m: fromDirectory
11:43:49 - [34mdebug[39m: fromDirectory
11:43:49 - [34mdebug[39m: fromDirectory
11:43:49 - [34mdebug[39m: constructor
11:43:49 - [34mdebug[39m: constructor
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processDirectory
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: fromDirectory
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:49 - [34mdebug[39m: isFileInNodeModuleDir
11:43:49 - [34mdebug[39m: processFile
11:43:52 - [34mdebug[39m: fromDirectory
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: processDirectory
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: processFile
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: processFile
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: processFile
11:43:52 - [34mdebug[39m: isFileInNodeModuleDir
11:43:52 - [34mdebug[39m: processFile
11:43:52 - [34mdebug[39m: fromDirectory
11:43:53 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:43:53 - [34mdebug[39m: fromDirectory
11:43:53 - [34mdebug[39m: isFileInNodeModuleDir
11:43:53 - [34mdebug[39m: processFile
11:43:53 - [34mdebug[39m: isFileInNodeModuleDir
11:43:53 - [34mdebug[39m: processFile
11:43:53 - [34mdebug[39m: isFileInNodeModuleDir
11:43:53 - [34mdebug[39m: processFile
11:43:53 - [34mdebug[39m: isFileInNodeModuleDir
11:43:53 - [34mdebug[39m: processFile
11:43:53 - [34mdebug[39m: isFileInNodeModuleDir
11:43:53 - [34mdebug[39m: processFile
11:43:53 - [34mdebug[39m: isFileInNodeModuleDir
11:43:53 - [34mdebug[39m: processFile
11:43:53 - [34mdebug[39m: isFileInNodeModuleDir
11:43:53 - [34mdebug[39m: processFile
11:43:53 - [34mdebug[39m: fromDirectory
11:43:53 - [34mdebug[39m: buildGrammar
11:43:53 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:43:53 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:43:53 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:43:53 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:43:53 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:43:53 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:43:53 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:43:53 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:43:53 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:43:53 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:43:53 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:43:53 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:43:53 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "c96c5830-8b09-4471-b6c8-3b0bcd3f891d",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:43:53 - [34mdebug[39m: fromDirectory
11:43:53 - [34mdebug[39m: fromDirectory
11:43:53 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"c96c5830-8b09-4471-b6c8-3b0bcd3f891d","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.01,"currencyCode":"TRY"}}
11:43:53 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"c96c5830-8b09-4471-b6c8-3b0bcd3f891d","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.01,"currencyCode":"TRY"}}
11:43:53 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35mc96c5830-8b09-4471-b6c8-3b0bcd3f891d[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.01[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
  [33m}[39m
[33m}[39m
11:44:17 - [32minfo[39m: Using current directory as template folder
11:44:17 - [32minfo[39m: Loading a default sample.txt file.
11:44:17 - [34mdebug[39m: fromDirectory
11:44:17 - [34mdebug[39m: fromDirectory
11:44:17 - [34mdebug[39m: fromDirectory
11:44:17 - [34mdebug[39m: fromDirectory
11:44:17 - [34mdebug[39m: fromDirectory
11:44:17 - [34mdebug[39m: fromDirectory
11:44:17 - [34mdebug[39m: fromDirectory
11:44:17 - [34mdebug[39m: constructor
11:44:17 - [34mdebug[39m: constructor
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processDirectory
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: fromDirectory
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:17 - [34mdebug[39m: isFileInNodeModuleDir
11:44:17 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: fromDirectory
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processDirectory
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: fromDirectory
11:44:20 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:44:20 - [34mdebug[39m: fromDirectory
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: isFileInNodeModuleDir
11:44:20 - [34mdebug[39m: processFile
11:44:20 - [34mdebug[39m: fromDirectory
11:44:20 - [34mdebug[39m: buildGrammar
11:44:20 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:44:20 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:44:20 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:44:20 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:44:20 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:44:20 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:44:20 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:44:20 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:44:20 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:44:20 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:44:20 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:44:20 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:44:20 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "53e91672-9183-4f18-b474-d1cfda4232b1",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:44:20 - [34mdebug[39m: fromDirectory
11:44:20 - [34mdebug[39m: fromDirectory
11:44:20 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"53e91672-9183-4f18-b474-d1cfda4232b1","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.09,"currencyCode":"TRY"}}
11:44:20 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"53e91672-9183-4f18-b474-d1cfda4232b1","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.09,"currencyCode":"TRY"}}
11:44:20 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35m53e91672-9183-4f18-b474-d1cfda4232b1[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.09[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
  [33m}[39m
[33m}[39m
11:46:16 - [32minfo[39m: Using current directory as template folder
11:46:16 - [32minfo[39m: Loading a default sample.txt file.
11:46:16 - [32minfo[39m: Loading a single default request.json file.
11:46:16 - [32minfo[39m: Loading a default state.json file.
11:46:16 - [34mdebug[39m: fromDirectory
11:46:16 - [34mdebug[39m: fromDirectory
11:46:16 - [34mdebug[39m: fromDirectory
11:46:16 - [34mdebug[39m: fromDirectory
11:46:16 - [34mdebug[39m: fromDirectory
11:46:16 - [34mdebug[39m: fromDirectory
11:46:16 - [34mdebug[39m: fromDirectory
11:46:16 - [34mdebug[39m: constructor
11:46:16 - [34mdebug[39m: constructor
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processDirectory
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: fromDirectory
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:16 - [34mdebug[39m: isFileInNodeModuleDir
11:46:16 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: fromDirectory
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processDirectory
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: fromDirectory
11:46:18 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:46:18 - [34mdebug[39m: fromDirectory
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: isFileInNodeModuleDir
11:46:18 - [34mdebug[39m: processFile
11:46:18 - [34mdebug[39m: fromDirectory
11:46:18 - [34mdebug[39m: buildGrammar
11:46:18 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:46:18 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:46:18 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:46:18 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:46:18 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:46:18 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:46:18 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:46:18 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:46:18 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:46:18 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:46:18 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:46:18 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:46:18 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "608991e1-4d47-4f52-8c3d-dab7ad003ac9",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:46:18 - [34mdebug[39m: fromDirectory
11:46:18 - [34mdebug[39m: fromDirectory
11:46:18 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"608991e1-4d47-4f52-8c3d-dab7ad003ac9","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.09,"currencyCode":"TRY"}}
11:46:18 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"608991e1-4d47-4f52-8c3d-dab7ad003ac9","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.09,"currencyCode":"TRY"}}
11:46:18 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
11:46:18 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
11:46:18 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
11:46:18 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-e65d823d4cf3ec58ec58136df5a9490850bb301f04870eaa194f76abe04fc1ea[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35m43b859f9-a8d8-4675-8b9e-f09308dfba6a[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-31T08:46:18.749Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.09[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#608991e1-4d47-4f52-8c3d-dab7ad003ac9[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#Can%20Do%C4%9Fan[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Corp.[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-31T08:46:18.749Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
11:49:03 - [32minfo[39m: Using current directory as template folder
11:49:03 - [32minfo[39m: Loading a default sample.txt file.
11:49:03 - [34mdebug[39m: fromDirectory
11:49:03 - [34mdebug[39m: fromDirectory
11:49:03 - [34mdebug[39m: fromDirectory
11:49:03 - [34mdebug[39m: fromDirectory
11:49:03 - [34mdebug[39m: fromDirectory
11:49:03 - [34mdebug[39m: fromDirectory
11:49:03 - [34mdebug[39m: fromDirectory
11:49:03 - [34mdebug[39m: constructor
11:49:03 - [34mdebug[39m: constructor
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processDirectory
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: fromDirectory
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:03 - [34mdebug[39m: isFileInNodeModuleDir
11:49:03 - [34mdebug[39m: processFile
11:49:05 - [34mdebug[39m: fromDirectory
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: processDirectory
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: processFile
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: processFile
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: processFile
11:49:05 - [34mdebug[39m: isFileInNodeModuleDir
11:49:05 - [34mdebug[39m: processFile
11:49:05 - [34mdebug[39m: fromDirectory
11:49:06 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:49:06 - [34mdebug[39m: fromDirectory
11:49:06 - [34mdebug[39m: isFileInNodeModuleDir
11:49:06 - [34mdebug[39m: processFile
11:49:06 - [34mdebug[39m: isFileInNodeModuleDir
11:49:06 - [34mdebug[39m: processFile
11:49:06 - [34mdebug[39m: isFileInNodeModuleDir
11:49:06 - [34mdebug[39m: processFile
11:49:06 - [34mdebug[39m: isFileInNodeModuleDir
11:49:06 - [34mdebug[39m: processFile
11:49:06 - [34mdebug[39m: isFileInNodeModuleDir
11:49:06 - [34mdebug[39m: processFile
11:49:06 - [34mdebug[39m: isFileInNodeModuleDir
11:49:06 - [34mdebug[39m: processFile
11:49:06 - [34mdebug[39m: isFileInNodeModuleDir
11:49:06 - [34mdebug[39m: processFile
11:49:06 - [34mdebug[39m: fromDirectory
11:49:06 - [34mdebug[39m: buildGrammar
11:49:06 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:49:06 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:49:06 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:49:06 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:49:06 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:49:06 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:49:06 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:49:06 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:49:06 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:49:06 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:49:06 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:49:06 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:49:06 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "b9bfb0bc-3eaf-45a8-861b-a876cc9580fb",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:49:06 - [34mdebug[39m: fromDirectory
11:49:06 - [34mdebug[39m: fromDirectory
11:49:06 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"b9bfb0bc-3eaf-45a8-861b-a876cc9580fb","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922,"currencyCode":"TRY"}}
11:49:06 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"b9bfb0bc-3eaf-45a8-861b-a876cc9580fb","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922,"currencyCode":"TRY"}}
11:49:06 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35mb9bfb0bc-3eaf-45a8-861b-a876cc9580fb[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
  [33m}[39m
[33m}[39m
11:49:33 - [32minfo[39m: Using current directory as template folder
11:49:33 - [32minfo[39m: Loading a default sample.txt file.
11:49:33 - [32minfo[39m: Loading a single default request.json file.
11:49:33 - [32minfo[39m: Loading a default state.json file.
11:49:33 - [34mdebug[39m: fromDirectory
11:49:33 - [34mdebug[39m: fromDirectory
11:49:33 - [34mdebug[39m: fromDirectory
11:49:33 - [34mdebug[39m: fromDirectory
11:49:33 - [34mdebug[39m: fromDirectory
11:49:33 - [34mdebug[39m: fromDirectory
11:49:33 - [34mdebug[39m: fromDirectory
11:49:34 - [34mdebug[39m: constructor
11:49:34 - [34mdebug[39m: constructor
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processDirectory
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: fromDirectory
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:34 - [34mdebug[39m: isFileInNodeModuleDir
11:49:34 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: fromDirectory
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processDirectory
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: fromDirectory
11:49:36 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:49:36 - [34mdebug[39m: fromDirectory
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: isFileInNodeModuleDir
11:49:36 - [34mdebug[39m: processFile
11:49:36 - [34mdebug[39m: fromDirectory
11:49:36 - [34mdebug[39m: buildGrammar
11:49:36 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:49:36 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:49:36 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:49:36 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:49:36 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:49:36 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:49:36 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:49:36 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:49:36 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:49:36 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:49:36 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:49:36 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:49:36 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "7b189fc9-fe77-40cb-977b-4c241b831ec5",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:49:36 - [34mdebug[39m: fromDirectory
11:49:36 - [34mdebug[39m: fromDirectory
11:49:36 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"7b189fc9-fe77-40cb-977b-4c241b831ec5","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:49:36 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"7b189fc9-fe77-40cb-977b-4c241b831ec5","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:49:36 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
11:49:36 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
11:49:36 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
11:49:36 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-aed13ba5e3dcf177ff7e636422f5b385e0d8bbacdc06ef590cd4626fb54f8807[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35m4e66922f-69c8-496c-83f1-a1003e581666[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-31T08:49:36.777Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.99[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#7b189fc9-fe77-40cb-977b-4c241b831ec5[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#Can%20Do%C4%9Fan[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Corp.[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-31T08:49:36.777Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
11:49:41 - [32minfo[39m: Using current directory as template folder
11:49:41 - [32minfo[39m: Loading a default sample.txt file.
11:49:41 - [34mdebug[39m: fromDirectory
11:49:41 - [34mdebug[39m: fromDirectory
11:49:41 - [34mdebug[39m: fromDirectory
11:49:41 - [34mdebug[39m: fromDirectory
11:49:41 - [34mdebug[39m: fromDirectory
11:49:41 - [34mdebug[39m: fromDirectory
11:49:41 - [34mdebug[39m: fromDirectory
11:49:41 - [34mdebug[39m: constructor
11:49:41 - [34mdebug[39m: constructor
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processDirectory
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: fromDirectory
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:41 - [34mdebug[39m: isFileInNodeModuleDir
11:49:41 - [34mdebug[39m: processFile
11:49:42 - [34mdebug[39m: fromDirectory
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: processDirectory
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: processFile
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: processFile
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: processFile
11:49:42 - [34mdebug[39m: isFileInNodeModuleDir
11:49:42 - [34mdebug[39m: processFile
11:49:42 - [34mdebug[39m: fromDirectory
11:49:43 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:49:43 - [34mdebug[39m: fromDirectory
11:49:43 - [34mdebug[39m: isFileInNodeModuleDir
11:49:43 - [34mdebug[39m: processFile
11:49:43 - [34mdebug[39m: isFileInNodeModuleDir
11:49:43 - [34mdebug[39m: processFile
11:49:43 - [34mdebug[39m: isFileInNodeModuleDir
11:49:43 - [34mdebug[39m: processFile
11:49:43 - [34mdebug[39m: isFileInNodeModuleDir
11:49:43 - [34mdebug[39m: processFile
11:49:43 - [34mdebug[39m: isFileInNodeModuleDir
11:49:43 - [34mdebug[39m: processFile
11:49:43 - [34mdebug[39m: isFileInNodeModuleDir
11:49:43 - [34mdebug[39m: processFile
11:49:43 - [34mdebug[39m: isFileInNodeModuleDir
11:49:43 - [34mdebug[39m: processFile
11:49:43 - [34mdebug[39m: fromDirectory
11:49:43 - [34mdebug[39m: buildGrammar
11:49:43 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:49:43 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:49:43 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:49:43 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:49:43 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:49:43 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:49:43 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:49:43 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:49:43 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:49:43 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:49:43 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:49:43 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:49:43 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "455b832c-e88f-46b2-8f06-b629dcfbedcc",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:49:43 - [34mdebug[39m: fromDirectory
11:49:43 - [34mdebug[39m: fromDirectory
11:49:43 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"455b832c-e88f-46b2-8f06-b629dcfbedcc","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:49:43 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"455b832c-e88f-46b2-8f06-b629dcfbedcc","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:49:43 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35m455b832c-e88f-46b2-8f06-b629dcfbedcc[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.99[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
  [33m}[39m
[33m}[39m
11:53:19 - [32minfo[39m: Using current directory as template folder
11:53:19 - [32minfo[39m: Loading a default sample.txt file.
11:53:19 - [34mdebug[39m: fromDirectory
11:53:19 - [34mdebug[39m: fromDirectory
11:53:19 - [34mdebug[39m: fromDirectory
11:53:19 - [34mdebug[39m: fromDirectory
11:53:19 - [34mdebug[39m: fromDirectory
11:53:19 - [34mdebug[39m: fromDirectory
11:53:19 - [34mdebug[39m: fromDirectory
11:53:19 - [34mdebug[39m: constructor
11:53:19 - [34mdebug[39m: constructor
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processDirectory
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: fromDirectory
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:19 - [34mdebug[39m: isFileInNodeModuleDir
11:53:19 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: fromDirectory
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processDirectory
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: fromDirectory
11:53:21 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:53:21 - [34mdebug[39m: fromDirectory
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: isFileInNodeModuleDir
11:53:21 - [34mdebug[39m: processFile
11:53:21 - [34mdebug[39m: fromDirectory
11:53:21 - [34mdebug[39m: buildGrammar
11:53:21 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:53:21 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:53:21 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:53:21 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:53:21 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:53:21 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:53:21 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:53:21 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:53:21 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:53:21 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:53:21 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:53:21 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:53:21 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "e1cfa135-8dbf-428c-80c9-5e673738da87",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:53:21 - [34mdebug[39m: fromDirectory
11:53:21 - [34mdebug[39m: fromDirectory
11:53:21 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"e1cfa135-8dbf-428c-80c9-5e673738da87","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:53:21 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"e1cfa135-8dbf-428c-80c9-5e673738da87","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:53:21 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35me1cfa135-8dbf-428c-80c9-5e673738da87[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.99[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
  [33m}[39m
[33m}[39m
11:53:32 - [32minfo[39m: Using current directory as template folder
11:53:32 - [32minfo[39m: Loading a default sample.txt file.
11:53:32 - [32minfo[39m: Loading a single default request.json file.
11:53:32 - [32minfo[39m: Loading a default state.json file.
11:53:32 - [34mdebug[39m: fromDirectory
11:53:32 - [34mdebug[39m: fromDirectory
11:53:32 - [34mdebug[39m: fromDirectory
11:53:32 - [34mdebug[39m: fromDirectory
11:53:32 - [34mdebug[39m: fromDirectory
11:53:32 - [34mdebug[39m: fromDirectory
11:53:32 - [34mdebug[39m: fromDirectory
11:53:32 - [34mdebug[39m: constructor
11:53:32 - [34mdebug[39m: constructor
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processDirectory
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: fromDirectory
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:32 - [34mdebug[39m: isFileInNodeModuleDir
11:53:32 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: fromDirectory
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processDirectory
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: fromDirectory
11:53:35 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:53:35 - [34mdebug[39m: fromDirectory
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: isFileInNodeModuleDir
11:53:35 - [34mdebug[39m: processFile
11:53:35 - [34mdebug[39m: fromDirectory
11:53:35 - [34mdebug[39m: buildGrammar
11:53:35 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:53:35 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:53:35 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:53:35 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:53:35 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:53:35 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:53:35 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:53:35 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:53:35 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:53:35 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:53:35 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:53:35 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:53:35 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "2655da2d-dda9-4f95-959b-6d1207fc92a6",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:53:35 - [34mdebug[39m: fromDirectory
11:53:35 - [34mdebug[39m: fromDirectory
11:53:35 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"2655da2d-dda9-4f95-959b-6d1207fc92a6","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:53:35 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"2655da2d-dda9-4f95-959b-6d1207fc92a6","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:53:35 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
11:53:35 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
11:53:35 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
11:53:35 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-bb664ff9bba9edae10b7771f7836ca557f8292eae9d87cf770ca3a1f9dd7754f[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35mb01c064c-896f-4707-b73c-e3f5dc1cbea2[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-31T08:53:35.897Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.99[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#2655da2d-dda9-4f95-959b-6d1207fc92a6[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#Can%20Do%C4%9Fan[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Corp.[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-31T08:53:35.897Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
11:54:16 - [32minfo[39m: Using current directory as template folder
11:54:16 - [32minfo[39m: Loading a default sample.txt file.
11:54:16 - [34mdebug[39m: fromDirectory
11:54:16 - [34mdebug[39m: fromDirectory
11:54:16 - [34mdebug[39m: fromDirectory
11:54:16 - [34mdebug[39m: fromDirectory
11:54:16 - [34mdebug[39m: fromDirectory
11:54:16 - [34mdebug[39m: fromDirectory
11:54:16 - [34mdebug[39m: fromDirectory
11:54:16 - [34mdebug[39m: constructor
11:54:16 - [34mdebug[39m: constructor
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processDirectory
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: fromDirectory
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:16 - [34mdebug[39m: isFileInNodeModuleDir
11:54:16 - [34mdebug[39m: processFile
11:54:20 - [34mdebug[39m: fromDirectory
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: processDirectory
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: processFile
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: processFile
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: processFile
11:54:20 - [34mdebug[39m: isFileInNodeModuleDir
11:54:20 - [34mdebug[39m: processFile
11:54:20 - [34mdebug[39m: fromDirectory
11:54:21 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:54:21 - [34mdebug[39m: fromDirectory
11:54:21 - [34mdebug[39m: isFileInNodeModuleDir
11:54:21 - [34mdebug[39m: processFile
11:54:21 - [34mdebug[39m: isFileInNodeModuleDir
11:54:21 - [34mdebug[39m: processFile
11:54:21 - [34mdebug[39m: isFileInNodeModuleDir
11:54:21 - [34mdebug[39m: processFile
11:54:21 - [34mdebug[39m: isFileInNodeModuleDir
11:54:21 - [34mdebug[39m: processFile
11:54:21 - [34mdebug[39m: isFileInNodeModuleDir
11:54:21 - [34mdebug[39m: processFile
11:54:21 - [34mdebug[39m: isFileInNodeModuleDir
11:54:21 - [34mdebug[39m: processFile
11:54:21 - [34mdebug[39m: isFileInNodeModuleDir
11:54:21 - [34mdebug[39m: processFile
11:54:21 - [34mdebug[39m: fromDirectory
11:54:21 - [34mdebug[39m: buildGrammar
11:54:21 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:54:21 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:54:21 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:54:21 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:54:21 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:54:21 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:54:21 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:54:21 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:54:21 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:54:21 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:54:21 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:54:21 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:54:21 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "c32deafc-1db6-40d1-9f03-5b66c6909a92",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:54:21 - [34mdebug[39m: fromDirectory
11:54:21 - [34mdebug[39m: fromDirectory
11:54:21 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"c32deafc-1db6-40d1-9f03-5b66c6909a92","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:54:21 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"c32deafc-1db6-40d1-9f03-5b66c6909a92","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:54:21 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentContract[39m[33m"[39m[33m,[39m
  [33m"[39m[32mcontractId[39m[33m"[39m[33m: [39m[33m"[39m[35mc32deafc-1db6-40d1-9f03-5b66c6909a92[39m[33m"[39m[33m,[39m
  [33m"[39m[32mbuyer[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mCan Doğan[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mseller[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.contract.AccordParty[39m[33m"[39m[33m,[39m
    [33m"[39m[32mpartyId[39m[33m"[39m[33m: [39m[33m"[39m[35mACME Corp.[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32minitialAmount[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
    [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.99[39m[33m,[39m
    [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
  [33m}[39m
[33m}[39m
11:54:25 - [32minfo[39m: Using current directory as template folder
11:54:25 - [32minfo[39m: Loading a default sample.txt file.
11:54:25 - [32minfo[39m: Loading a single default request.json file.
11:54:25 - [32minfo[39m: Loading a default state.json file.
11:54:25 - [34mdebug[39m: fromDirectory
11:54:25 - [34mdebug[39m: fromDirectory
11:54:25 - [34mdebug[39m: fromDirectory
11:54:25 - [34mdebug[39m: fromDirectory
11:54:25 - [34mdebug[39m: fromDirectory
11:54:25 - [34mdebug[39m: fromDirectory
11:54:25 - [34mdebug[39m: fromDirectory
11:54:25 - [34mdebug[39m: constructor
11:54:25 - [34mdebug[39m: constructor
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processDirectory
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: fromDirectory
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:25 - [34mdebug[39m: isFileInNodeModuleDir
11:54:25 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: fromDirectory
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processDirectory
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: fromDirectory
11:54:30 - [34mdebug[39m: Compiled Ergo to Javascript:
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Initialize inheritance */
var inheritance = null;
/* "standard library" (implementation of unary and binary operators) */
function unwrap(doc) {
    // Unwrap for Enhanced TxStore format
    if ("state" in doc && !("$class" in doc)) {
        if (doc.state == "COMMITTED")
            return JSON.parse(doc.currentValue);
        else
            return null; // Not sure if we will need something more fancy for un-committed data
    }
    // Leave as-is
    else
        return doc;
}
function concat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2)
        if (!(key2 in r1))
            result[key2] = r2[key2];
    return result;
}
function contains(v, b) {
    for (var i=0; i<b.length; i++)
        if (equal(v, toLeft(b[i])))
            return true;
    return false;
}
function distinct(b) {
    var result = [ ];
    for (var i=0; i<b.length; i++) {
        var v = b[i];
        var dup = false;
        for (var j=0; j<result.length;j++) {
            if (equal(v,result[j])) { dup = true; break; }
        }
        if (!(dup)) { result.push(v); } else { dup = false; }
    }
    return result;
}
function fastdistinct(b) {
    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    b1.sort(compare);
    var result = [ ];
    var v1 = null;
    var v2 = null;
    for (var i=0; i<b1.length; i++) {
        var v1 = b1[i];
        if (i == (b1.length -1)) {
            result.push(v1);
        }
        else {
            v2 = b1[i+1];
            if (equal(v1,v2)) {
            } else {
                result.push(v1);
            }
            v1 = v2;
        }
    }
    return result;
}
function compare(v1, v2) {
    var t1 = typeof v1, t2 = typeof v2;
    if (t1 != t2)
        return t1 < t2 ? -1 : +1;
    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);
    if (a1 != a2)
        return a1 < a2 ? -1 : +1;
    if (a1 == "[object Array]") {
        v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
        v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */
        v1.sort(compare);
        v2.sort(compare);
    }
    if (t1 == "object") {
        var fields1 = [];
        var fields2 = [];
        for (var f1 in v1) { fields1.push(f1); }
        for (var f2 in v2) { fields2.push(f2); }
        fields1 = fields1.sort(compare);
        fields2 = fields2.sort(compare);
        for (var i = 0; i < fields1.length; i++) {
            if (!(fields1[i] in v2))
                return -1;
            var fc = compare(v1[fields1[i]], v2[fields1[i]]);
            if (fc != 0)
                return fc;
        }
        for (var i = 0; i < fields2.length; i++) {
            if (!(fields2[i] in v1))
                return +1;
        }
        return 0;
    }
    if (v1 != v2)
        return v1 < v2 ? -1 : +1;
    return 0;
}
function equal(v1, v2) {
    return compare(v1, v2) == 0;
}
function compareOfMultipleCriterias(scl) {
    return function(a,b) {
        var current_compare = 0;
        for (var i=0; i<scl.length; i++) {
            var sc = scl[i];
            if ("asc" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }
            else if ("desc" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }

            if (current_compare == -1) { return -1; }
            else if(current_compare == 1) { return 1; }
        }
        return current_compare;
    }
    
}
function sort(b,scl) {
    var result = [ ];
    if (scl.length == 0) { return b; } // Check for no sorting criteria
    var compareFun = compareOfMultipleCriterias(scl);
    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */
    result.sort(compareFun);
    return result;
}
function flatten(aOuter) {
    var result = [ ];
    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {
        var aInner = aOuter[iOuter];
        for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)
            result.push(aInner[iInner]);
    }
    return result;
}
function mergeConcat(r1, r2) {
    var result = { };
    for (var key1 in r1)
        result[key1] = r1[key1];
    for (var key2 in r2) {
        if (key2 in r1) {
            if (!equal(r1[key2], r2[key2])) {
                return [ ];
            }
        } else {
            result[key2] = r2[key2];
        }
    }
    return [ result ];
}
function project(r1, p2) {
    var result = { };
    for (var key1 in r1) {
        if (!(p2.indexOf(key1) == -1))
            result[key1] = r1[key1];
    }
    return result;
}
function remove(r, f) {
    var result = { };
    for (var key in r)
        if (key != f)
            result[key] = r[key];
    return result;
}
function sum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i];
    return result;
}
function arithMean(b) {
    var len = b.length;
    if(len == 0) {
        return 0;
    } else {
        return sum(b)/len;
    }
}
function toString(v) {
    return toStringQ(v, "");
}
function toStringQ(v, quote) {
    if (v === null)
        return "null";
    var t = typeof v;
    if (t == "string")
        return quote + v + quote;
    if (t == "boolean")
        return "" + v;
    if (t == "number") {
        if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point
        else return "" + v;
    }
    if ({}.toString.apply(v) == "[object Array]") {
        v = v.slice();
        v.sort();
        var result = "[";
        for (var i=0, n=v.length; i<n; i++) {
            if (i > 0)
                result += ", ";
            result += toStringQ(v[i], quote);
        }
        return result + "]";
    }
    if(v.hasOwnProperty('nat')){
        return "" + v.nat;
    }
    var result2 = "{";
    var first = true;
    for (var key in v) {
        if (first) first = false; else result2 += ", ";
        result2 += toStringQ(key, quote) + ": " + toStringQ(v[key], quote);
    }
    return result2 + "}";
}
function bunion(b1, b2) {
    var result = [ ];
    for (var i1=0; i1<b1.length; i1++)
        result.push(b1[i1]);
    for (var i2=0; i2<b2.length; i2++)
        result.push(b2[i2]);
    return result;
}
function bminus(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }
        } else {
            result.push(v1[i1]);
        }
    }
    return result;
}
function bmin(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);
        }
    }
    return result;
}
function bmax(b1, b2) {
    var result = [ ];
    var v1 = b1.slice();
    var v2 = b2.slice();
    v1.sort(compare);
    v2.sort(compare);
    var i2=0;
    var length2=v2.length;
    var comp=0;
    for (var i1=0; i1<v1.length; i1++) {
        while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }
        if (i2 < length2) {
            if(compare(v1[i1],v2[i2]) == 0) i2++;
        }
        result.push(v1[i1]);
    }
    while (i2 < length2) { result.push(v2[i2]); i2++; }
    return result;
}
function sub_brand(b1,b2) {
    var bsub=null;
    var bsup=null;
    var inh = [];
    if (inheritance) { inh = inheritance; };
    for (var i=0; i<inh.length; i++) {
        bsub = inh[i].sub;
        bsup = inh[i].sup;
        if ((b1 == bsub) && (b2 == bsup)) return true;
    }
    return false;
}
function left(v) {
    return { left : v };
}
function right(v) {
    return { right : v };
}
function mustBeArray(obj) {
    if (Array.isArray(obj))
        return;
    var e = new Error("Expected an array but got: " + JSON.stringify(obj));
    throw e;
}
function cast(brands,v) {
    //logger.info("CASTING: "+brands[0]);
    //logger.info("FOR OBJECT: "+JSON.stringify(v));
    mustBeArray(brands);
    if ("$class" in v)
        return enhanced_cast(brands,v);
    var type = v.type;
    mustBeArray(type);
    if (brands.length == 1 && brands[0] == "Any") { /* cast to top of inheritance is built-in */
        return left(v);
    }
    brands:
    for (var i in brands) {
        var b = brands[i];
        for (var j in type) {
            var t = type[j];
            if (equal(t,b) || sub_brand(t,b))
                continue brands;
        }
        /* the brand b does not appear in the type, so the cast fails */
        return right(null);
    }
    /* All brands appear in the type, so the cast succeeds */
    return left(v);
}
function enhanced_cast(brands,v) {
    var type = v.$class;
    if (brands.length != 1)
        throw "Can't handle multiple brands yet";
    var brand = brands[0];
    if (brand == type || brand == "Any" || sub_brand(type, brand)) {
        return left(v);
    }
    return right(null);
}
function singleton(v) {
    if (v.length == 1) {
        return left(v[0]);
    } else {
        return right(null); /* Not a singleton */
    }
}
function unbrand(v) {
    if (typeof v === "object")
        if ("$class" in v) {
            return remove(v,"$class");
        } else {
            return ("data" in v) ? v.data : v;
        }
    throw "TypeError: unbrand called on non-object";
}
function brand(b,v) {
    v['$class'] = b[0];
    return v
}
function either(v) {
    if (v == null)
        return false;
    if (typeof v === "object")
        return !("right" in v);
    return true;
}
function toLeft(v) {
    if (typeof v === "object") {
        if ("left" in v)
            return v.left;
        if ("$value" in v)
            return v.$value;
        if (looksLikeRelationship(v))
            return v["key"];
    }
    return v;
}
function toRight(v) {
    if (v === null)
        return null;
    if (typeof v === "object" && "right" in v)
        return v.right;
    return undefined;
}
function deref(receiver, member) {
    if (typeof receiver === "object" && member in receiver) {
        var ans = receiver[member];
        if (ans === null) {
            return null;
        }
        if (typeof ans === "object" && looksLikeRelationship(ans))
            ans = left(ans["key"]);
        if (("$class" in receiver) && typeof ans === "object" && !("left" in ans) && !Array.isArray(ans))
            ans = left(ans);
        return ans;
    }
    return undefined;
}
function looksLikeRelationship(v) {
    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.
    // A "key" and "type" member must be among those.   A third member, if present, must be $class and must denote
    // the relationship class.
    var hasKey = false;
    var hasType = false;
    for (var member in v)
        if (member == "key")
            hasKey = true;
    else if (member == "type")
        hasType = true;
    else if (member == "$class" && v["$class"] == "com.ibm.ia.model.Relationship")
        continue;
    else
        return false;
    return hasKey && hasType;
}
function mkWorld(v) {
    return { "WORLD" : v };
}

// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
function escapeRegExp(string){
    return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}

// Nat operations

function natPlus(v1, v2) {
    return { "nat" : v1.nat + v2.nat };
}
function natMinus(v1, v2) {
    return { "nat" : v1.nat - v2.nat };
}
function natMult(v1, v2) {
    return { "nat" : v1.nat * v2.nat };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natDiv(v1, v2) {
    return { "nat" : Math.floor(v1.nat / v2.nat) };
}
function natRem(v1, v2) {
    return { "nat" : Math.floor(v1.nat % v2.nat) };
}
function natMin(v1, v2) {
    return { "nat" : Math.min(v1.nat,v2.nat) };
}
function natMax(v1, v2) {
    return { "nat" : Math.max(v1.nat,v2.nat) };
}
function natAbs(v) {
    return { "nat" : Math.abs(v.nat) };
}
function natLog2(v) {
    return { "nat" : Math.floor(Math.log2(v.nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2
}
function natSqrt(v) {
    return { "nat" : Math.floor(Math.sqrt(v.nat)) }; // See Z.sqrt biggest integer lower than sqrt
}
function natSum(b) {
    var result = 0;
    for (var i=0; i<b.length; i++)
        result += b[i].nat;
    return { "nat" : result };
}
function natMinApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.min.apply(Math,numbers) };
}
function natMaxApply(b) {
    var numbers = [ ];
    for (var i=0; i<b.length; i++)
        numbers.push(b[i].nat);
    return { "nat" : Math.max.apply(Math,numbers) };
}
function natArithMean(b) {
    var len = b.length;
    if(len == 0) {
        return { "nat" : 0 };
    } else {
        return { "nat" : Math.floor(natSum(b)/len) };
    }
}
function count(v) {
    //return { "nat" : v.length };
    return v.length; /* XXX To be fixed */
}
function floatOfNat(v) {
    return v.nat;
}
function substring(v, start, len) {
    return v.substring(start,len);
}
function substringNoLength(v, start) {
    return v.substring(start);
}
/* Addendum to for dateTime and duration */

var DAY = "day";
var MONTH = "month";
var QUARTER = "quarter";
var YEAR = "year";

function dateTimeComponent(part, date) {
    date = mustBeDate(date);
    switch(part) {
    case DAY:
        return date.dayOfMonth();
    case MONTH:
        return date.month();
    case YEAR:
        return date.year();
    case QUARTER:
        return date.quarter();
    default:
        throw new Error("Unknown date part: " + part);
    }
}

function dateTimeFromString(stringDate) {
    return moment(stringDate);
}

function dateTimeDurationFromString(stringDuration) {
    // TODO verify what the string format for durations is going to be.
    // Here we assume a number adjoined to a valid unit with a dash.
    if (typeof stringDuration === "string") {
	      parts = stringDuration.split("-");
	      if (parts.length === 2) {
	          mustBeUnit(parts[1]);
            return moment.duration(parseFloat(parts[0]),parts[1]+"s");
        }
    }
    throw new Error("Not well formed duration input: " + stringDuration);
}

function dateTimePointPlus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.add(duration);
}

function dateTimePointMinus(date, duration) {
    date = mustBeDate(date);
    duration = mustBeDuration(duration);
    return date.substract(duration);
}

function dateTimePointNe(date1, date2) {
    return compareDates(date1, date2) != 0;
}

function dateTimePointLt(date1, date2) {
    return compareDates(date1,date2) < 0;
}

function dateTimePointLe(date1, date2) {
    return compareDates(date1, date2) <= 0;
}

function dateTimePointGt(date1, date2) {
    return compareDates(date1, date2) > 0;
}

function dateTimePointGe(date1, date2) {
    return compareDates(date1, date2) >= 0;
}

function dateTimeDurationDays(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'days');
}
function dateTimeDurationSeconds(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    return date1.diff(date2,'seconds');
}

function compareDates(date1, date2) {
    date1 = mustBeDate(date1);
    date2 = mustBeDate(date2);
    if (date1.isBefore(date2)) {
        return -1;
    } else if (date1.isAfter(date2)) {
        return 1;
    } else if (date1.isSame(date2)) {
        return 0;
    }
    throw new Error("Unexpected failure: compareDates")
}

function dateNewYear(date, year) {
    date = mustBeDate(date);
    return date.year(year);
}

function dateNewMonth(date, month) {
    date = mustBeDate(date);
    return date.month(month);
}

function dateNewDay(date, day) {
    date = mustBeDate(date);
    return date.day(day);
}

function makeDate(year, month, day) {
    return moment({ 'year' :year, 'month' :month, 'day' :day });
}

function mustBeDate(date) {
    if (typeof date == "string") {
        return moment(date);
    } else {
        return date.clone();
    }
}

function mustBeDuration(duration) {
    if (typeof duration == "string") {
        return moment.duration(duration);
    } else {
        return duration.clone();
    }
}

function mustBeUnit(unit) {
    if (unit === DAY || unit === MONTH || unit === QUARTER || unit === YEAR)
	      return;
    throw new Error("Expected a duration unit but got " + JSON.stringify(unit));
}

'use strict';
/*eslint-disable no-unused-vars*/
/*eslint-disable no-undef*/
/*eslint-disable no-var*/


/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.InitRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.InitResponse} context.response - the response
 * @param {org.accordproject.cicero.runtime.PaymentObligation} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogicInit
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_init(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': { '$class': 'org.accordproject.cicero.contract.AccordContractState', 'stateId' : 'org.accordproject.cicero.contract.AccordContractState#1' }, 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().init(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}

/**
 * Execute the smart clause
 * @param {Context} context - the Accord context
 * @param {org.accordtr.onetimepayment.PaymentReceivedRequest} context.request - the incoming request
 * @param {org.accordtr.onetimepayment.PaymentReceivedResponse} context.response - the response
 * @param {org.hyperledger.composer.system.Event} context.emit - the emitted events
 * @param {org.accordproject.cicero.contract.AccordContractState} context.state - the state
 * @AccordClauseLogic
 */
function orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context) {
  let pcontext = { 'request' : serializer.toJSON(context.request,{permitResourcesForRelationships:true}), 'state': serializer.toJSON(context.state,{permitResourcesForRelationships:true}), 'contract': serializer.toJSON(context.contract,{permitResourcesForRelationships:true}), 'emit': context.emit, 'now': context.now};
  //logger.info('ergo context: '+JSON.stringify(pcontext))
  let result = new orgXaccordtrXonetimepaymentXonetimepayment().paymentReceived(pcontext);
  if (result.hasOwnProperty('left')) {
    //logger.info('ergo result: '+JSON.stringify(result))
    context.response = serializer.fromJSON(result.left.response, {validate: false, acceptResourcesForRelationships: true},{permitResourcesForRelationships:true});
    context.state = serializer.fromJSON(result.left.state, {validate: false, acceptResourcesForRelationships: true});
    let emitResult = [];
    for (let i = 0; i < result.left.emit.length; i++) {
      emitResult.push(serializer.fromJSON(result.left.emit[i], {validate: false, acceptResourcesForRelationships: true}));
    }
    context.emit = emitResult;
    return context;
  } else {
    throw new Error(result.right);
  }
}
class orgXaccordtrXonetimepaymentXonetimepayment {
  main(context) {
    var vnow = deref(context, "now");
    var vcontract = deref(context, "contract");
    var vrequest = deref(context, "request");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_1 = vstate;
    var vlemit_0 = vemit;
    var vX$match0 = vrequest;
    var res1 = null;
    if (either(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0))) {
      var vX$case0 = null;
      vX$case0 = toLeft(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"left" : {"$main": vX$case0}};
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(cast(["org.accordtr.onetimepayment.PaymentReceivedRequest"],vX$match0));
      res1 = {"right" : null};
    }
    var res3 = null;
    if (either(res1)) {
      var vX$case0_0 = null;
      vX$case0_0 = toLeft(res1);
      var vX$case0 = vX$case0_0;
      var vX$main = deref(vX$case0, "$main");
      var vrequest_0 = vX$main;
      var vemit_0 = vlemit_0;
      var vstate_0 = vlstate_1;
      var vcontract_0 = vcontract;
      var vnow_0 = vnow;
      var vlstate_0 = vstate_0;
      var vlemit = vemit_0;
      var t2;
      if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
        t2 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
      } else {
        var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
        t2 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
      }
      res3 = t2;
    } else {
      var vX$case1 = null;
      vX$case1 = toRight(res1);
      res3 = {"right" : brand(["org.accordproject.cicero.runtime.ErrorResponse"],{"message": ""})};
    }
    return res3;
  }
  paymentReceived(context) {
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit = vemit;
    var t1;
    if (!(equal(deref(unbrand(vlstate_0), "status"), "OBLIGATION_EMITTED"))) {
      t1 = {"right" : "Either a payment obligation hasn't yet been emitted by the contract or payment notification has already been received"};
    } else {
      var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": deref(unbrand(vlstate_0), "stateId")}, {"status": "COMPLETED"}));
      t1 = {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.PaymentReceivedResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
    }
    return t1;
  }
  init(context) {
    var vcontract = deref(context, "contract");
    var vemit = deref(context, "emit");
    var vstate = deref(context, "state");
    var vlstate_0 = vstate;
    var vlemit_0 = vemit;
    var vlemit = bunion([brand(["org.accordproject.cicero.runtime.PaymentObligation"],concat(concat(concat(concat({"contract": deref(unbrand(vcontract), "contractId")}, {"promisor": deref(unbrand(vcontract), "buyer")}), {"promisee": deref(unbrand(vcontract), "seller")}), {"amount": deref(unbrand(vcontract), "initialAmount")}), {"description": ((deref(unbrand(vcontract), "buyer") + " should pay contract amount to ") + deref(unbrand(vcontract), "seller"))}))], vlemit_0);
    var vlstate = brand(["org.accordtr.onetimepayment.OneTimePaymentState"],concat({"stateId": "1"}, {"status": "OBLIGATION_EMITTED"}));
    return {"left" : concat(concat({"response": brand(["org.accordtr.onetimepayment.InitResponse"],{})}, {"state": vlstate}), {"emit": vlemit})};
  }
}

/*eslint-enable no-unused-vars*/
/*eslint-enable no-undef*/



11:54:30 - [34mdebug[39m: fromDirectory
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: isFileInNodeModuleDir
11:54:30 - [34mdebug[39m: processFile
11:54:30 - [34mdebug[39m: fromDirectory
11:54:30 - [34mdebug[39m: buildGrammar
11:54:30 - [34mdebug[39m: Template AST {"type":"ContractTemplate","data":[{"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}},{"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}},{"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30},{"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}},{"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43},{"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}},{"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70},{"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}},{"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}]}
11:54:30 - [34mdebug[39m: element rule0 {"type":"Chunk","value":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka ","text":"TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka [{","offset":0,"lineBreaks":6,"line":1,"col":1}
11:54:30 - [34mdebug[39m: element rule1 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":234,"lineBreaks":0,"line":7,"col":21}}
11:54:30 - [34mdebug[39m: element rule2 {"type":"Chunk","value":"\n        1.2 Müşteri ","text":"\n        1.2 Müşteri [{","offset":242,"lineBreaks":1,"line":7,"col":29}
11:54:30 - [34mdebug[39m: element rule3 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":265,"lineBreaks":0,"line":8,"col":23}}
11:54:30 - [34mdebug[39m: element rule4 {"type":"Chunk","value":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of ","text":"\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of [{","offset":272,"lineBreaks":30,"line":8,"col":30}
11:54:30 - [34mdebug[39m: element rule5 {"type":"Binding","fieldName":{"type":"varid","value":"initialAmount","text":"initialAmount","offset":2428,"lineBreaks":0,"line":38,"col":28}}
11:54:30 - [34mdebug[39m: element rule6 {"type":"Chunk","value":" shall be made by ","text":" shall be made by [{","offset":2443,"lineBreaks":0,"line":38,"col":43}
11:54:30 - [34mdebug[39m: element rule7 {"type":"Binding","fieldName":{"type":"varid","value":"buyer","text":"buyer","offset":2463,"lineBreaks":0,"line":38,"col":63}}
11:54:30 - [34mdebug[39m: element rule8 {"type":"Chunk","value":" to ","text":" to [{","offset":2470,"lineBreaks":0,"line":38,"col":70}
11:54:30 - [34mdebug[39m: element rule9 {"type":"Binding","fieldName":{"type":"varid","value":"seller","text":"seller","offset":2476,"lineBreaks":0,"line":38,"col":76}}
11:54:30 - [34mdebug[39m: element rule10 {"type":"LastChunk","value":" upon execution of this Agreement.","text":" upon execution of this Agreement.","offset":2484,"lineBreaks":0,"line":38,"col":84}
11:54:31 - [34mdebug[39m: Generated template grammar# Dynamically Generated
@builtin "number.ne"
@builtin "string.ne"
@builtin "whitespace.ne"
@{%
    function compact(v) {
        if (Array.isArray(v)) {
            return v.reduce((a, v) => (v === null || v === undefined || (v && v.length === 0) ) ? a : (a.push(v), a), []);
        } else {
            return v;
        }
    }

    function flatten(v) {
        let r;
        if (Array.isArray(v)) {
            r = v.reduce((a,v) => (a.push(...((v && Array.isArray(v)) ? flatten(v) : [v])), a), []);
        } else {
            r = v;
        }
        r = compact(r);
        return r;
        }
%}


rule -> rule0 rule1 rule2 rule3 rule4 rule5 rule6 rule7 rule8 rule9 rule10 
{% ([ rule0,rule1,rule2,rule3,rule4,rule5,rule6,rule7,rule8,rule9,rule10 ]) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        contractId : "29b55cd3-cdf3-4f3a-85f8-5873d6e8e121",
        buyer : rule3,
        seller : rule1,
        initialAmount : rule5,
    };
}
%}

ROOT -> rule0 
{% ([ rule0 ]) => {
    return {
        
        
    };
}
%}



rule0 -> "TEK SEFERLİK ÖDEME HİZMETİ SÖZLEŞMESİ\n\nİşbu tek seferlik ödeme hizmeti sözleşmesi (\"Sözleşme\"), aşağıda adı ve ünvanı belirtilen Taraflar arasında \"12/07/2018\" tarihinde imzalanmıştır.\n\n1. TARAFLAR\n\n        1.1 Banka " 


rule1 -> AccordParty {% id %} # seller 


rule2 -> "\n        1.2 Müşteri " 


rule3 -> AccordParty {% id %} # buyer 


rule4 -> "\n\n2. SÖZLEŞMENİN KONUSU\n\n        İşbu Sözleşme uyarınca Banka tarafından Müşteri’ye Müşteri’nin yürütmekte olduğu \"ithalat ihracat\" faaliyetleri kapsamında, Taraflar’ca kararlaştırılan ücret karşılığında,\n        tek seferlik elektronik fon transferi, havale veya virman işlemi sunulacaktır.\n\n3. ÖDEME EMRİNİN ALINMA ZAMANI\n\n        Müşteri tarafından gönderilen ödeme emri Banka’nın iş saatleri içinde ve her halükarda saat 17.00’dan geç olmamak üzere Banka’ya ulaştığı an alınmış sayılır.\n        Saat 17:00’dan sonra alınan ödeme emri Banka tarafından ertesi iş günü alınmış sayılır. Ödeme emri, Banka tarafından alınmasından itibaren incelenir ve aynı\n        gün sonuna kadar ödeme emrinin reddi sebeplerinin varlığı halinde Müşteri’ye red gerekçelerini bildirir.\n\n4. ÖDEMENİN GERÇEKLEŞTİRİLMESİ\n\n        4.1. Ödeme emrinin Banka’ya verilmesi anından itibaren, Banka işlemi yapmadan önce Müşteri emrinden dönebilir. Ancak Banka işlemi tamamladıktan sonra işlemin geri\n        alınması mümkün olmayan durumlarda Banka’nın sorumluluğu söz konusu olmaz. Müşterinin Banka’ya vereceği ödeme emrinde hangi döviz cinsi üzerinden işlem yapacağını\n        belirtmekle yükümlüdür. Döviz cinsi üzerinden yapılacak işlemlerde bankanın cari döviz kurları üzerinden işlem yapılacağını Müşteri kabul ve beyan eder.\n\n        4.2. Müşteri, hata veya kusuru sonucu Banka’nın ödeme işlemini gerçekleştirememesi veya hatalı gerçekleştirmesi halinde Banka’nın sorumlu tutulmayacağını kabul ve taahhüt eder.\n\n5. ÖDEME HİZMETİNE İLİŞKİN ÜCRET\n\n        Müşteri, işbu Sözleşme kapsamında gerçekleştirilecek ödemeyle ilgili Banka’nın sağlamış olduğu hizmetler için Banka’ya ücret ödemeyi kabul ve taahhüt eder.\n\n6. ÖDEME İŞLEMLERİNE İLİŞKİN BİLGİLENDİRME\n\n        Müşteri, Banka’nın kendisini işbu Sözleşme’nin hükümleri hakkında işbu Sözleşme imzalanmadan önce bilgilendirdiğini, Banka’nın internet sitesinde taslak sözleşme örneğini\n        incelediği ve kendisine sözleşmenin imzalı bir kopyasını verdiğini beyan ve kabul eder.\n\n7. An initial payment of " 


rule5 -> MonetaryAmount {% id %} # initialAmount 


rule6 -> " shall be made by " 


rule7 -> AccordParty {% id %} # buyer 


rule8 -> " to " 


rule9 -> AccordParty {% id %} # seller 


rule10 -> " upon execution of this Agreement." 


InitRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


InitResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.InitResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedRequest -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedRequest",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentReceivedResponse -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.PaymentReceivedResponse",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


OneTimePaymentState -> ContractLifecycleStatus  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentState",
        status : data[0],
        stateId : data[2]
    };
}
%}


ContractLifecycleStatus -> "UNINITIALIZED" {% id %} | "OBLIGATION_EMITTED" {% id %} | "COMPLETED" {% id %} 


OneTimePaymentContract -> AccordParty  __  AccordParty  __  MonetaryAmount  __  String  __  String 

{% ( data ) => {
    return {
        $class: "org.accordtr.onetimepayment.OneTimePaymentContract",
        buyer : data[0],
        seller : data[2],
        initialAmount : data[4],
        contractId : data[6],
        parties : data[8]
    };
}
%}


AccordContractState -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordContractState",
        stateId : data[0]
    };
}
%}


AccordParty -> String 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.contract.AccordParty",
        partyId : data[0]
    };
}
%}


Request -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Request",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


Response -> String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Response",
        transactionId : data[0],
        timestamp : data[2]
    };
}
%}


PaymentObligation -> MonetaryAmount  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.PaymentObligation",
        amount : data[0],
        description : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


NotificationObligation -> String  __  String  __  String  __  String  __  String  __  DateTime:?  __  String  __  DateTime 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.NotificationObligation",
        title : data[0],
        message : data[2],
        contract : data[4],
        promisor : data[6],
        promisee : data[8],
        deadline : data[10],
        eventId : data[12],
        timestamp : data[14]
    };
}
%}


Payload -> AccordContract  __  Request  __  AccordContractState:? 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Payload",
        contract : data[0],
        request : data[2],
        state : data[4]
    };
}
%}


Success -> Response  __  AccordContractState  __  Event:+ 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Success",
        response : data[0],
        state : data[2],
        emit : data[4]
    };
}
%}


Failure -> ErrorResponse 

{% ( data ) => {
    return {
        $class: "org.accordproject.cicero.runtime.Failure",
        error : data[0]
    };
}
%}


CryptoMonetaryAmount -> Double  __  CryptoCurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.CryptoMonetaryAmount",
        doubleValue : data[0],
        cryptoCurrencyCode : data[2]
    };
}
%}


CryptoCurrencyCode -> "ADA" {% id %} | "BCH" {% id %} | "BTC" {% id %} | "DASH" {% id %} | "EOS" {% id %} | "ETC" {% id %} | "ETH" {% id %} | "LTC" {% id %} | "NEO" {% id %} | "XLM" {% id %} | "XMR" {% id %} | "XRP" {% id %} | "ZEC" {% id %} 


MonetaryAmount -> Double  __  CurrencyCode 

{% ( data ) => {
    return {
        $class: "org.accordproject.money.MonetaryAmount",
        doubleValue : data[0],
        currencyCode : data[2]
    };
}
%}


CurrencyCode -> "AED" {% id %} | "AFN" {% id %} | "ALL" {% id %} | "AMD" {% id %} | "ANG" {% id %} | "AOA" {% id %} | "ARS" {% id %} | "AUD" {% id %} | "AWG" {% id %} | "AZN" {% id %} | "BAM" {% id %} | "BBD" {% id %} | "BDT" {% id %} | "BGN" {% id %} | "BHD" {% id %} | "BIF" {% id %} | "BMD" {% id %} | "BND" {% id %} | "BOB" {% id %} | "BOV" {% id %} | "BRL" {% id %} | "BSD" {% id %} | "BTN" {% id %} | "BWP" {% id %} | "BYN" {% id %} | "BZD" {% id %} | "CAD" {% id %} | "CDF" {% id %} | "CHE" {% id %} | "CHF" {% id %} | "CHW" {% id %} | "CLF" {% id %} | "CLP" {% id %} | "CNY" {% id %} | "COP" {% id %} | "COU" {% id %} | "CRC" {% id %} | "CUC" {% id %} | "CUP" {% id %} | "CVE" {% id %} | "CZK" {% id %} | "DJF" {% id %} | "DKK" {% id %} | "DOP" {% id %} | "DZD" {% id %} | "EGP" {% id %} | "ERN" {% id %} | "ETB" {% id %} | "EUR" {% id %} | "FJD" {% id %} | "FKP" {% id %} | "GBP" {% id %} | "GEL" {% id %} | "GHS" {% id %} | "GIP" {% id %} | "GMD" {% id %} | "GNF" {% id %} | "GTQ" {% id %} | "GYD" {% id %} | "HKD" {% id %} | "HNL" {% id %} | "HRK" {% id %} | "HTG" {% id %} | "HUF" {% id %} | "IDR" {% id %} | "ILS" {% id %} | "INR" {% id %} | "IQD" {% id %} | "IRR" {% id %} | "ISK" {% id %} | "JMD" {% id %} | "JOD" {% id %} | "JPY" {% id %} | "KES" {% id %} | "KGS" {% id %} | "KHR" {% id %} | "KMF" {% id %} | "KPW" {% id %} | "KRW" {% id %} | "KWD" {% id %} | "KYD" {% id %} | "KZT" {% id %} | "LAK" {% id %} | "LBP" {% id %} | "LKR" {% id %} | "LRD" {% id %} | "LSL" {% id %} | "LYD" {% id %} | "MAD" {% id %} | "MDL" {% id %} | "MGA" {% id %} | "MKD" {% id %} | "MMK" {% id %} | "MNT" {% id %} | "MOP" {% id %} | "MRU" {% id %} | "MUR" {% id %} | "MVR" {% id %} | "MWK" {% id %} | "MXN" {% id %} | "MXV" {% id %} | "MYR" {% id %} | "MZN" {% id %} | "NAD" {% id %} | "NGN" {% id %} | "NIO" {% id %} | "NOK" {% id %} | "NPR" {% id %} | "NZD" {% id %} | "OMR" {% id %} | "PAB" {% id %} | "PEN" {% id %} | "PGK" {% id %} | "PHP" {% id %} | "PKR" {% id %} | "PLN" {% id %} | "PYG" {% id %} | "QAR" {% id %} | "RON" {% id %} | "RSD" {% id %} | "RUB" {% id %} | "RWF" {% id %} | "SAR" {% id %} | "SBD" {% id %} | "SCR" {% id %} | "SDG" {% id %} | "SEK" {% id %} | "SGD" {% id %} | "SHP" {% id %} | "SLL" {% id %} | "SOS" {% id %} | "SRD" {% id %} | "SSP" {% id %} | "STN" {% id %} | "SVC" {% id %} | "SYP" {% id %} | "SZL" {% id %} | "THB" {% id %} | "TJS" {% id %} | "TMT" {% id %} | "TND" {% id %} | "TOP" {% id %} | "TRY" {% id %} | "TTD" {% id %} | "TWD" {% id %} | "TZS" {% id %} | "UAH" {% id %} | "UGX" {% id %} | "USD" {% id %} | "USN" {% id %} | "UYI" {% id %} | "UYU" {% id %} | "UZS" {% id %} | "VEF" {% id %} | "VND" {% id %} | "VUV" {% id %} | "WST" {% id %} | "XAF" {% id %} | "XAG" {% id %} | "XAU" {% id %} | "XBA" {% id %} | "XBB" {% id %} | "XBC" {% id %} | "XBD" {% id %} | "XCD" {% id %} | "XDR" {% id %} | "XOF" {% id %} | "XPD" {% id %} | "XPF" {% id %} | "XPT" {% id %} | "XSU" {% id %} | "XTS" {% id %} | "XUA" {% id %} | "XXX" {% id %} | "YER" {% id %} | "ZAR" {% id %} | "ZMW" {% id %} | "ZWL" {% id %} 



# Basic types
NUMBER -> [0-9] 
{% (d) => {return parseInt(d[0]);}%}

DOUBLE_NUMBER -> NUMBER NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

MONTH -> DOUBLE_NUMBER
DAY -> DOUBLE_NUMBER
YEAR -> DOUBLE_NUMBER DOUBLE_NUMBER
{% (d) => {return '' + d[0] + d[1]}%}

DATE -> MONTH "/" DAY "/" YEAR
{% (d) => {return '' + d[4] + '-' + d[0] + '-' + d[2]}%}

Word -> [\S]:*
{% (d) => {return d[0].join('');}%}

BRACKET_PHRASE -> "[" Word (__ Word):* "]" {% ((d) => {return d[1] + ' ' + flatten(d[2]).join(" ");}) %}

String -> dqstring {% id %}
Double -> decimal {% id %}
Integer -> int {% id %}
Long -> int {% id %}
Boolean -> "true" {% id %} | "false" {% id %}
DateTime -> DATE  {% id %}
11:54:31 - [34mdebug[39m: fromDirectory
11:54:31 - [34mdebug[39m: fromDirectory
11:54:31 - [34mdebug[39m: Result of parsing: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"29b55cd3-cdf3-4f3a-85f8-5873d6e8e121","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:54:31 - [34mdebug[39m: Setting clause data: {"$class":"org.accordtr.onetimepayment.OneTimePaymentContract","contractId":"29b55cd3-cdf3-4f3a-85f8-5873d6e8e121","buyer":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"Can Doğan"},"seller":{"$class":"org.accordproject.cicero.contract.AccordParty","partyId":"ACME Corp."},"initialAmount":{"$class":"org.accordproject.money.MonetaryAmount","doubleValue":1922.99,"currencyCode":"TRY"}}
11:54:31 - [34mdebug[39m: Engine processing request org.accordtr.onetimepayment.InitRequest with state org.accordproject.cicero.contract.AccordContractState
11:54:31 - [34mdebug[39m: 
        __dispatch(contract,data,request,state,moment());

        function __dispatch(contract,data,request,state,now) {
            switch(request.getFullyQualifiedType()) {
        
            case 'org.accordtr.onetimepayment.InitRequest':
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, state: state, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
            break;
            case 'org.accordtr.onetimepayment.PaymentReceivedRequest':
                let type1 = 'org.accordtr.onetimepayment.PaymentReceivedResponse';
                let ns1 = type1.substr(0, type1.lastIndexOf('.'));
                let clazz1 = type1.substr(type1.lastIndexOf('.')+1);
                let response1 = factory.newTransaction(ns1, clazz1);
                let context1 = {request: request, state: state, contract: contract, data: data, response: response1, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_paymentReceived(context1);
                return { response: context1.response, state: context1.state, emit: context1.emit };
            break;
            default:
                throw new Error('No function handler for ' + request.getFullyQualifiedType() );
            } // switch
            return 'oops';
        }
        
11:54:31 - [34mdebug[39m: 
        __init(contract,data,request,moment());

        function __init(contract,data,request,now) {
        
                let type0 = 'org.accordtr.onetimepayment.InitResponse';
                let ns0 = type0.substr(0, type0.lastIndexOf('.'));
                let clazz0 = type0.substr(type0.lastIndexOf('.')+1);
                let response0 = factory.newTransaction(ns0, clazz0);
                let context0 = {request: request, contract: contract, data: data, response: response0, emit: [], now: now};
                orgXaccordtrXonetimepaymentXonetimepayment_init(context0);
                return { response: context0.response, state: context0.state, emit: context0.emit };
        }
        
11:54:31 - [32minfo[39m:
[33m{[39m
  [33m"[39m[32mclause[39m[33m"[39m[33m: [39m[33m"[39m[35mone-time-payment-tr@0.0.0-1ae896a964153c9cecdaac840d1cb553fcfe20a9b46f331a2472b7c3bc213bee[39m[33m"[39m[33m,[39m
  [33m"[39m[32mrequest[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitRequest[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mresponse[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.InitResponse[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtransactionId[39m[33m"[39m[33m: [39m[33m"[39m[35mf59dbd11-a337-44cd-816b-865f47146b8e[39m[33m"[39m[33m,[39m
    [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-31T08:54:31.204Z[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32mstate[39m[33m"[39m[33m: [39m[33m{[39m
    [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordtr.onetimepayment.OneTimePaymentState[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstatus[39m[33m"[39m[33m: [39m[33m"[39m[35mOBLIGATION_EMITTED[39m[33m"[39m[33m,[39m
    [33m"[39m[32mstateId[39m[33m"[39m[33m: [39m[33m"[39m[35m1[39m[33m"[39m
  [33m}[39m[33m,[39m
  [33m"[39m[32memit[39m[33m"[39m[33m: [39m[33m[[39m
    [33m{[39m
      [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.cicero.runtime.PaymentObligation[39m[33m"[39m[33m,[39m
      [33m"[39m[32mamount[39m[33m"[39m[33m: [39m[33m{[39m
        [33m"[39m[32m$class[39m[33m"[39m[33m: [39m[33m"[39m[35morg.accordproject.money.MonetaryAmount[39m[33m"[39m[33m,[39m
        [33m"[39m[32mdoubleValue[39m[33m"[39m[33m: [39m[36m1922.99[39m[33m,[39m
        [33m"[39m[32mcurrencyCode[39m[33m"[39m[33m: [39m[33m"[39m[35mTRY[39m[33m"[39m
      [33m}[39m[33m,[39m
      [33m"[39m[32mdescription[39m[33m"[39m[33m: [39m[33m"[39m[35m[object Object] should pay contract amount to [object Object][39m[33m"[39m[33m,[39m
      [33m"[39m[32mcontract[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordContract#29b55cd3-cdf3-4f3a-85f8-5873d6e8e121[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisor[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#Can%20Do%C4%9Fan[39m[33m"[39m[33m,[39m
      [33m"[39m[32mpromisee[39m[33m"[39m[33m: [39m[33m"[39m[35mresource:org.accordproject.cicero.contract.AccordParty#ACME%20Corp.[39m[33m"[39m[33m,[39m
      [33m"[39m[32meventId[39m[33m"[39m[33m: [39m[33m"[39m[35mvalid[39m[33m"[39m[33m,[39m
      [33m"[39m[32mtimestamp[39m[33m"[39m[33m: [39m[33m"[39m[35m2018-07-31T08:54:31.204Z[39m[33m"[39m
    [33m}[39m
  [33m][39m
[33m}[39m
